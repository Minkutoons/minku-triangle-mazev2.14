<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Rock n Roll: Ball Maze Challenge â€“ Minku</title>
<style>
body{margin:0;background:#111;color:#fff;font-family:Arial}
#top{padding:8px;background:#1a1a1a;display:flex;gap:10px;align-items:center}
button{padding:6px 10px;border-radius:6px;border:none;background:#333;color:#fff}
canvas{display:block;width:100vw;height:90vh;touch-action:none}
</style>
</head>
<body>
<div id="errPanel" style="position:fixed;left:10px;right:10px;bottom:10px;max-height:42vh;overflow:auto;z-index:9999;
background:rgba(0,0,0,.72);color:#fff;font:12px/1.35 ui-monospace,Menlo,Consolas,monospace;padding:10px;border-radius:12px;
border:1px solid rgba(255,255,255,.18);display:none;white-space:pre-wrap;"></div>


<div id="top">
<button id="restart">Restart</button>
<button id="comfort">Comfort: ON</button>
<span id="info">Triangle</span>
</div>

<canvas id="cv"></canvas>

<script>
(function(){
  const p=()=>document.getElementById('errPanel');
  function show(msg){ const e=p(); if(!e) return; e.style.display='block'; e.textContent += msg + "\n"; }
  window.addEventListener('error', (ev)=> show("[error] " + (ev.message||"") + " @ " + (ev.filename||"") + ":" + (ev.lineno||"")));
  window.addEventListener('unhandledrejection', (ev)=> show("[promise] " + (ev.reason && (ev.reason.stack||ev.reason.message) || String(ev.reason))));
})();

const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");

function resize(){
  cv.width = window.innerWidth;
  cv.height = window.innerHeight*0.9;
}
resize();
setTimeout(()=>{ try{ if (typeof updatePocketCompare==='function') updatePocketCompare(); }catch(e){ const p=document.getElementById('errPanel'); if(p){p.style.display='block'; p.textContent += '[init] '+(e.stack||e.message||e)+'\n';}} }, 0);
window.onresize = resize;

let shape = "triangle";
let comfortMode = true;

let ball = {x:0,y:0,vx:0,vy:0,r:12};

function resetBall(){
  ball.x = cv.width/2;
  ball.y = cv.height/2 - 200;
  ball.vx = ball.vy = 0;
}
resetBall();

document.getElementById("restart").onclick = resetBall;

document.getElementById("comfort").onclick = ()=>{
  comfortMode = !comfortMode;
  document.getElementById("comfort").textContent =
    "Comfort: " + (comfortMode?"ON":"OFF");
};

let tiltX=0, tiltY=0;
window.addEventListener("deviceorientation",(e)=>{
  let gx=e.gamma||0;
  let by=e.beta||0;

  if(comfortMode){
    tiltX = by/30;
    tiltY = -gx/30;
  }else{
    tiltX = gx/30;
    tiltY = by/30;
  }
});

function drawShape(R){
  let cx=cv.width/2;
  let cy=cv.height/2;

  ctx.strokeStyle="#555";
  ctx.lineWidth=5;
  ctx.beginPath();

  if(shape==="circle"){
    ctx.arc(cx,cy,R,0,Math.PI*2);
  }

  if(shape==="square"){
    ctx.rect(cx-R,cy-R,R*2,R*2);
  }

  if(shape==="rect"){
    ctx.rect(cx-R*1.2,cy-R*0.7,R*2.4,R*1.4);
  }

  if(shape==="triangle"){
    ctx.moveTo(cx,cy-R);
    ctx.lineTo(cx+R*Math.cos(Math.PI/6),
               cy+R*Math.sin(Math.PI/6));
    ctx.lineTo(cx-R*Math.cos(Math.PI/6),
               cy+R*Math.sin(Math.PI/6));
    ctx.closePath();
  }

  ctx.stroke();
}

function drawRings(R){
  let cx=cv.width/2;
  let cy=cv.height/2;
  let spacing = R/6;

  ctx.strokeStyle="#777";
  ctx.lineWidth=4;

  for(let i=1;i<=4;i++){
    ctx.beginPath();

    if(shape==="circle"){
      ctx.arc(cx,cy,R-i*spacing,0,Math.PI*2);
    }

    if(shape==="square"){
      ctx.rect(cx-(R-i*spacing),
               cy-(R-i*spacing),
               (R-i*spacing)*2,
               (R-i*spacing)*2);
    }

    if(shape==="rect"){
      ctx.rect(cx-(R-i*spacing)*1.2,
               cy-(R-i*spacing)*0.7,
               (R-i*spacing)*2.4,
               (R-i*spacing)*1.4);
    }

    if(shape==="triangle"){
      let r2=R-i*spacing;
      ctx.moveTo(cx,cy-r2);
      ctx.lineTo(cx+r2*Math.cos(Math.PI/6),
                 cy+r2*Math.sin(Math.PI/6));
      ctx.lineTo(cx-r2*Math.cos(Math.PI/6),
                 cy+r2*Math.sin(Math.PI/6));
      ctx.closePath();
    }

    ctx.stroke();
  }
}

// -------- Pixel Engine (Triangle) : Center Pocket Compare --------
var PIX = { grid: 200, angles: 240, safety: 2 };
let pocket = null;

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function buildTriangleMask(grid){
  const mask = new Uint8Array(grid*grid);
  const cxg = grid/2, cyg = grid/2;
  const Rg = (grid/2) * 0.92;
  const ax = cxg, ay = cyg - Rg;
  const bx = cxg + Rg*Math.cos(Math.PI/6), by = cyg + Rg*Math.sin(Math.PI/6);
  const cx2 = cxg - Rg*Math.cos(Math.PI/6), cy2 = cyg + Rg*Math.sin(Math.PI/6);

  function sign(px,py, x1,y1, x2,y2){ return (px-x2)*(y1-y2) - (x1-x2)*(py-y2); }
  function inTri(px,py){
    const d1 = sign(px,py, ax,ay, bx,by);
    const d2 = sign(px,py, bx,by, cx2,cy2);
    const d3 = sign(px,py, cx2,cy2, ax,ay);
    const hasNeg = (d1<0)||(d2<0)||(d3<0);
    const hasPos = (d1>0)||(d2>0)||(d3>0);
    return !(hasNeg && hasPos);
  }

  for(let y=0;y<grid;y++){
    for(let x=0;x<grid;x++){
      const px = x + 0.5, py = y + 0.5;
      mask[y*grid+x] = inTri(px,py) ? 1 : 0;
    }
  }
  return mask;
}

function computeInsideDistance(mask, grid){
  const inf = 1e9;
  const dist = new Float32Array(grid*grid);
  for(let i=0;i<dist.length;i++) dist[i]=inf;

  const qx = new Int16Array(grid*grid);
  const qy = new Int16Array(grid*grid);
  let qs=0, qe=0;

  const idx=(x,y)=>y*grid+x;

  // boundary seeds
  for(let y=0;y<grid;y++){
    for(let x=0;x<grid;x++){
      const i=idx(x,y);
      if(!mask[i]) continue;
      let boundary=false;
      for(let oy=-1; oy<=1 && !boundary; oy++){
        for(let ox=-1; ox<=1; ox++){
          if(ox===0 && oy===0) continue;
          const xx=x+ox, yy=y+oy;
          if(xx<0||yy<0||xx>=grid||yy>=grid){ boundary=true; break; }
          if(mask[idx(xx,yy)]===0){ boundary=true; break; }
        }
      }
      if(boundary){
        dist[i]=0;
        qx[qe]=x; qy[qe]=y; qe++;
      }
    }
  }

  const dirs=[
    [1,0,1],[-1,0,1],[0,1,1],[0,-1,1],
    [1,1,1.4142],[1,-1,1.4142],[-1,1,1.4142],[-1,-1,1.4142]
  ];

  while(qs<qe){
    const x=qx[qs], y=qy[qs]; qs++;
    const base=dist[idx(x,y)];
    for(const d of dirs){
      const xx=x+d[0], yy=y+d[1];
      if(xx<0||yy<0||xx>=grid||yy>=grid) continue;
      const ii=idx(xx,yy);
      if(!mask[ii]) continue;
      const nd=base+d[2];
      if(nd<dist[ii]){
        dist[ii]=nd;
        qx[qe]=xx; qy[qe]=yy; qe++;
      }
    }
  }

  let Rmax=0;
  for(let i=0;i<dist.length;i++) if(mask[i] && dist[i]<inf && dist[i]>Rmax) Rmax=dist[i];
  return {dist,Rmax};
}

function rayMinToBoundary(mask, grid, angles){
  const cxg=grid/2, cyg=grid/2;
  let minD=1e9;
  for(let k=0;k<angles;k++){
    const a=(k/angles)*Math.PI*2;
    const dx=Math.cos(a), dy=Math.sin(a);
    let t=0;
    for(let step=0; step<grid*3; step++){
      const x=cxg+dx*t, y=cyg+dy*t;
      const ix=x|0, iy=y|0;
      if(ix<0||iy<0||ix>=grid||iy>=grid) break;
      if(mask[iy*grid+ix]===0){ minD=Math.min(minD,t); break; }
      t += 0.6;
    }
  }
  return minD;
}

function updatePocketCompare(){
  const grid=PIX.grid;
  const mask=buildTriangleMask(grid);
  const {dist,Rmax}=computeInsideDistance(mask,grid);

  const ball = window.ball || {r:12};
  const ballDpx=(ball.r||12)*2;
  const rMinPx = 2.2 * ballDpx; // locked

  const R_canvas = Math.min(cv.width, cv.height)*0.42;
  const gridToCanvas = R_canvas / ((grid/2)*0.92);
  const rMin = rMinPx / gridToCanvas;

  const minRay = rayMinToBoundary(mask, grid, PIX.angles);
  const rCircleMax = Math.max(0, minRay - (PIX.safety+0.5));
  const areaCircle = Math.PI * rCircleMax * rCircleMax;

  let count=0;
  for(let i=0;i<dist.length;i++) if(mask[i] && dist[i] >= rMin) count++;
  const areaSDF = count;

  const chosen = (areaCircle >= areaSDF) ? "circle" : "sdf";
  pocket = {grid,mask,dist,Rmax,rMin,rCircleMax,areaCircle,areaSDF,chosen,gridToCanvas};

  const dbg=document.getElementById('debug');
  if(dbg){
    dbg.textContent =
`Center pocket compare (pixel engine)
ballD(px): ${ballDpx.toFixed(0)}  | rMin(px): ${rMinPx.toFixed(0)}
rMin(grid): ${rMin.toFixed(2)}
Circle rMax(grid): ${rCircleMax.toFixed(2)}
SDF Rmax(grid): ${Rmax.toFixed(2)}
Area circle(~cells): ${areaCircle.toFixed(0)}
Area sdf(cells): ${areaSDF}
Chosen: ${chosen.toUpperCase()}`;
  }
}

function drawPocketOverlay(){
  if(!pocket) return;
  const {grid,mask,dist,rMin,rCircleMax,chosen,gridToCanvas}=pocket;
  const cx=cv.width/2, cy=cv.height/2;
  const scale=gridToCanvas;
  const ox=cx-(grid/2)*scale, oy=cy-(grid/2)*scale;

  ctx.save();
  ctx.globalAlpha=0.35;
  if(chosen==="circle"){
    ctx.fillStyle="#00ffd0";
    ctx.beginPath();
    ctx.arc(cx,cy,rCircleMax*scale,0,Math.PI*2);
    ctx.fill();
  }else{
    ctx.fillStyle="#ff4dd8";
    for(let y=0;y<grid;y++){
      for(let x=0;x<grid;x++){
        const i=y*grid+x;
        if(mask[i] && dist[i] >= rMin){
          ctx.fillRect(ox+x*scale, oy+y*scale, scale, scale);
        }
      }
    }
  }
  ctx.restore();

  ctx.save();
  ctx.globalAlpha=0.75;
  ctx.strokeStyle="#00ffd0"; ctx.lineWidth=3;
  ctx.beginPath(); ctx.arc(cx,cy,rCircleMax*scale,0,Math.PI*2); ctx.stroke();

  ctx.strokeStyle="#ff4dd8"; ctx.lineWidth=2;
  for(let y=1;y<grid-1;y++){
    for(let x=1;x<grid-1;x++){
      const i=y*grid+x;
      if(!(mask[i] && dist[i] >= rMin)) continue;
      const n=[i-1,i+1,i-grid,i+grid];
      if(n.some(j=> !(mask[j] && dist[j] >= rMin))){
        ctx.strokeRect(ox+x*scale, oy+y*scale, scale, scale);
      }
    }
  }
  ctx.restore();
}
// ---------------------------------------------------------------

// ---- Triangle boundary clamp (keeps ball inside triangle for compare builds) ----
function clamp2(v,a,b){ return Math.max(a, Math.min(b, v)); }
function closestPointOnSegment2(px,py, ax,ay, bx,by){
  const abx=bx-ax, aby=by-ay;
  const apx=px-ax, apy=py-ay;
  const t = clamp2((apx*abx + apy*aby) / (abx*abx + aby*aby + 1e-9), 0, 1);
  return { x: ax + abx*t, y: ay + aby*t };
}
function pointInTri2(px,py, ax,ay, bx,by, cx,cy){
  const v0x=cx-ax, v0y=cy-ay;
  const v1x=bx-ax, v1y=by-ay;
  const v2x=px-ax, v2y=py-ay;
  const dot00=v0x*v0x+v0y*v0y;
  const dot01=v0x*v1x+v0y*v1y;
  const dot02=v0x*v2x+v0y*v2y;
  const dot11=v1x*v1x+v1y*v1y;
  const dot12=v1x*v2x+v1y*v2y;
  const invDen = 1/(dot00*dot11 - dot01*dot01 + 1e-9);
  const u = (dot11*dot02 - dot01*dot12)*invDen;
  const v = (dot00*dot12 - dot01*dot02)*invDen;
  return (u>=0)&&(v>=0)&&(u+v<=1);
}
function clampBallToTriangle(ball, ax,ay, bx,by, cx,cy){
  const edges=[[ax,ay,bx,by],[bx,by,cx,cy],[cx,cy,ax,ay]];
  if(!pointInTri2(ball.x, ball.y, ax,ay, bx,by, cx,cy)){
    let best=null, bestD2=1e30;
    for(const e of edges){
      const p=closestPointOnSegment2(ball.x, ball.y, e[0],e[1], e[2],e[3]);
      const dx=ball.x-p.x, dy=ball.y-p.y;
      const d2=dx*dx+dy*dy;
      if(d2<bestD2){ bestD2=d2; best=p; }
    }
    ball.x=best.x; ball.y=best.y;
  }
  for(const e of edges){
    const p=closestPointOnSegment2(ball.x, ball.y, e[0],e[1], e[2],e[3]);
    const dx=ball.x-p.x, dy=ball.y-p.y;
    const d=Math.hypot(dx,dy)+1e-9;
    if(d<ball.r){
      const push=(ball.r-d);
      ball.x += (dx/d)*push;
      ball.y += (dy/d)*push;
      ball.vx *= 0.92; ball.vy *= 0.92;
    }
  }
}

function loop(){
  ctx.clearRect(0,0,cv.width,cv.height);

  let cx=cv.width/2;
  let cy=cv.height/2;
  let R=250;

  drawShape(R);
  drawRings(R);

  ball.vx += tiltX;
  ball.vy += tiltY;
  ball.vx *= 0.98;
  ball.vy *= 0.98;
  ball.x += ball.vx;
  ball.y += ball.vy;

  if(ball.x < cx-R+ball.r) ball.x = cx-R+ball.r;
  if(ball.x > cx+R-ball.r) ball.x = cx+R-ball.r;
  if(ball.y < cy-R+ball.r) ball.y = cy-R+ball.r;
  if(ball.y > cy+R-ball.r) ball.y = cy+R-ball.r;

  ctx.fillStyle="gold";
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
  ctx.fill();

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
