<!-- index.html  (single file test build)
Rock n Roll: Ball Maze Challenge â€“ Minku  |  Shapes: Triangleâ†’Squareâ†’Rectangleâ†’Circle (Circle unlock @ L5)
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Rock n Roll: Ball Maze Challenge â€“ Minku (Test)</title>
<style>
  :root { --bg:#141414; --panel:#1f1f1f; --text:#f3f3f3; --muted:#b9b9b9; --accent:#ffd54a; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
  #top{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px 12px;background:linear-gradient(#1a1a1a,#111);border-bottom:1px solid #2a2a2a}
  .left,.right{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{background:var(--panel);border:1px solid #2b2b2b;border-radius:999px;padding:6px 10px;font-size:12px;color:var(--muted)}
  .btn{background:var(--panel);border:1px solid #2b2b2b;border-radius:10px;padding:8px 10px;color:var(--text);font-weight:600}
  .btn:active{transform:translateY(1px)}
  .btn.primary{border-color:#3a3418;background:#2a2412;color:#ffeaa0}
  .slider{display:flex;gap:8px;align-items:center}
  input[type=range]{width:120px}
 #cv{flex:1;display:block;touch-action:none;width:100%;height:100%;}
  #hint{position:fixed;left:12px;bottom:10px;color:#bdbdbd;font-size:12px;opacity:.9}
</style>
</head>
<body>
<div id="wrap">
  <div id="top">
    <div class="left">
      <div class="pill"><b style="color:#fff">Rock n Roll</b> â€¢ Minku</div>
      <div class="pill" id="status">L1 â€¢ TRIANGLE â€¢ Circle ðŸ”’</div>
      <button class="btn" id="restart">Restart</button>
      <button class="btn" id="prev">Prev</button>
      <button class="btn primary" id="next">Next</button>
    </div>
    <div class="right">
      <div class="slider pill">
        Chamfer
        <input id="chamfer" type="range" min="0" max="30" value="14" />
      </div>
      <div class="pill">Tilt: <span id="tiltTxt">0,0</span></div>
    </div>
  </div>
  <canvas id="cv"></canvas>
</div>
<div id="hint">Tilt phone or use Arrow keys / WASD. Goal: reach center.</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const statusEl = document.getElementById('status');
  const tiltTxt = document.getElementById('tiltTxt');
  const chamferEl = document.getElementById('chamfer');

  // ---------- Resize ----------
function resize(){
  const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
  const w = cv.parentElement.clientWidth;
  const h = cv.parentElement.clientHeight;
  cv.width  = Math.floor(w * dpr);
  cv.height = Math.floor(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('load', resize);
window.addEventListener('resize', resize);
resize();

  // ---------- Level plan (keep simple, dopamine-friendly) ----------
  // L1 Triangle, L2 Square, L3 Rectangle, L4 Mixed easy, L5 unlock Circle (classic)
  // After L5, cycle shapes but keep circle frequent.
  const SHAPES = ["triangle","square","rect","circle"];
  function shapeForLevel(L){
    if (L===1) return "triangle";
    if (L===2) return "square";
    if (L===3) return "rect";
    if (L===4) return ["triangle","square","rect"][ (L-1)%3 ];
    if (L>=5) return (L%3===2) ? "circle" : (L%3===0 ? "square" : "rect"); // circle often
    return "square";
  }
  function ringCountForLevel(L){
    // gentle rise
    if (L<=2) return 6;
    if (L<=5) return 7;
    if (L<=10) return 8;
    if (L<=15) return 9;
    return 10;
  }
  function cutoutWidthForLevel(L){
    // degrees: easy â†’ smaller slowly (but not punishing)
    if (L<=2) return 70;
    if (L<=5) return 60;
    if (L<=10) return 52;
    if (L<=15) return 46;
    return 42;
  }
  function wallThicknessForLevel(L){
    return (L<=5) ? 10 : (L<=12 ? 11 : 12);
  }

  // ---------- Input tilt ----------
  let tiltX = 0, tiltY = 0;
  let keyX = 0, keyY = 0;

  // Device tilt
  window.addEventListener('deviceorientation', (e) => {
    // gamma: left-right, beta: front-back
    const gx = (e.gamma ?? 0);
    const by = (e.beta ?? 0);
    tiltX = Math.max(-20, Math.min(20, gx)) / 20;
    tiltY = Math.max(-20, Math.min(20, by)) / 20;
  }, {passive:true});

  // Keyboard
  const keys = new Set();
  window.addEventListener('keydown', (e)=>{ keys.add(e.key.toLowerCase()); });
  window.addEventListener('keyup',   (e)=>{ keys.delete(e.key.toLowerCase()); });
  function updateKeys(){
    keyX = 0; keyY = 0;
    if (keys.has('arrowleft') || keys.has('a')) keyX -= 1;
    if (keys.has('arrowright')|| keys.has('d')) keyX += 1;
    if (keys.has('arrowup')   || keys.has('w')) keyY -= 1;
    if (keys.has('arrowdown') || keys.has('s')) keyY += 1;
    const m = Math.hypot(keyX,keyY) || 1;
    keyX/=m; keyY/=m;
  }

  // ---------- Geometry: SDF for shapes ----------
  // All shapes centered at (0,0). boundary size controlled by "R" (roughly half-min dimension).
  function sdfCircle(x,y,R){ return Math.hypot(x,y) - R; }

  // axis-aligned box (square/rect) with half-extents (hx,hy)
  function sdfBox(x,y,hx,hy){
    const ax = Math.abs(x) - hx;
    const ay = Math.abs(y) - hy;
    const ox = Math.max(ax,0), oy = Math.max(ay,0);
    const outside = Math.hypot(ox,oy);
    const inside = Math.min(Math.max(ax,ay),0);
    return outside + inside;
  }

  // Equilateral triangle SDF (Inigo Quilez style, adapted)
  function sdfEquiTri(x,y,R){
    // R ~ circumradius-ish, tuned
    const k = Math.sqrt(3);
    x = Math.abs(x) - R;
    y = y + R/k;
    if (x + k*y > 0){
      const nx = (x - k*y)/2;
      const ny = (-k*x - y)/2;
      x = nx; y = ny;
    }
    x -= Math.max(Math.min(x,0), -2*R);
    return -Math.hypot(x,y) * Math.sign(y);
  }

  function sdfShape(shape, x,y, R){
    if (shape==="circle") return sdfCircle(x,y,R);
    if (shape==="square") return sdfBox(x,y,R,R);
    if (shape==="rect")   return sdfBox(x,y,R*1.15,R*0.85);
    if (shape==="triangle") return sdfEquiTri(x,y,R*0.95);
    return sdfCircle(x,y,R);
  }

  function gradSdf(shape, x,y,R){
    // numeric gradient (cheap, stable)
    const e = 0.8;
    const dx = sdfShape(shape,x+e,y,R) - sdfShape(shape,x-e,y,R);
    const dy = sdfShape(shape,x,y+e,R) - sdfShape(shape,x,y-e,R);
    const m = Math.hypot(dx,dy) || 1;
    return {gx: dx/m, gy: dy/m};
  }

  // ---------- Maze definition ----------
  let level = 1;
  let shape = shapeForLevel(level);
  let rings = ringCountForLevel(level);
  let cutW = cutoutWidthForLevel(level) * Math.PI/180;
  let wallT = wallThicknessForLevel(level);
  let ringSpacing = 18; // computed each frame from boundary

  // cutout per ring: center angle + width
  let cutouts = []; // [{a,w}]
  function regenMaze(){
    shape = shapeForLevel(level);
    rings = ringCountForLevel(level);
    cutW  = cutoutWidthForLevel(level) * Math.PI/180;
    wallT = wallThicknessForLevel(level);

    // simple pattern: cutouts rotate ring by ring (keeps solvable & fun)
    cutouts = [];
    let base = (Math.random()*Math.PI*2);
    for(let i=1;i<=rings;i++){
      const a = base + i*0.9; // offset each ring
      const w = cutW * (1 - i*0.015); // tiny tighten inward
      cutouts.push({a, w: Math.max(w, 0.45)});
    }
    resetBall();
    updateStatus();
  }

  function updateStatus(){
    const s = shape.toUpperCase();
    const circleLocked = (level<5) ? "Circle ðŸ”’" : "Circle âœ…";
    statusEl.textContent = `L${level} â€¢ ${s} â€¢ ${circleLocked}`;
  }

  // ---------- Ball ----------
  const ball = { x:0, y:0, vx:0, vy:0, r:10 };
  function resetBall(){
    ball.vx = ball.vy = 0;
    // spawn near outer area but safely inside
    ball.x = -80;
    ball.y = -60;
  }

  // ---------- UI ----------
  document.getElementById('restart').onclick = () => resetBall();
  document.getElementById('prev').onclick = () => { level = Math.max(1, level-1); regenMaze(); };
  document.getElementById('next').onclick = () => { level = Math.min(30, level+1); regenMaze(); };

  // ---------- Draw helpers ----------
  function drawChamferedPoly(points, chamfer){
    // points in order
    const n = points.length;
    if (n<3){ return; }
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const p0 = points[(i-1+n)%n], p1 = points[i], p2 = points[(i+1)%n];
      const v1x = p0.x - p1.x, v1y = p0.y - p1.y;
      const v2x = p2.x - p1.x, v2y = p2.y - p1.y;
      const l1 = Math.hypot(v1x,v1y) || 1;
      const l2 = Math.hypot(v2x,v2y) || 1;
      const c = Math.min(chamfer, l1*0.35, l2*0.35);
      const a1x = p1.x + (v1x/l1)*c, a1y = p1.y + (v1y/l1)*c;
      const a2x = p1.x + (v2x/l2)*c, a2y = p1.y + (v2y/l2)*c;
      if (i===0) ctx.moveTo(a1x,a1y);
      else ctx.lineTo(a1x,a1y);
      ctx.lineTo(a2x,a2y);
    }
    ctx.closePath();
  }

  function pathBoundary(shape, R, chamfer){
    if (shape==="circle"){
      ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2);
      return;
    }
    if (shape==="square"){
      const pts=[{x:-R,y:-R},{x:R,y:-R},{x:R,y:R},{x:-R,y:R}];
      drawChamferedPoly(pts, chamfer); return;
    }
    if (shape==="rect"){
      const hx=R*1.15, hy=R*0.85;
      const pts=[{x:-hx,y:-hy},{x:hx,y:-hy},{x:hx,y:hy},{x:-hx,y:hy}];
      drawChamferedPoly(pts, chamfer); return;
    }
    if (shape==="triangle"){
      const r=R*0.95;
      const pts=[
        {x:0,y:-r},
        {x: r*Math.cos(Math.PI/6), y: r*Math.sin(Math.PI/6)},
        {x:-r*Math.cos(Math.PI/6), y: r*Math.sin(Math.PI/6)},
      ];
      drawChamferedPoly(pts, chamfer); return;
    }
    ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2);
  }

  // ---------- Physics: keep ball inside boundary + ring walls w/ cutouts ----------
  function applyCollisions(shape, R){
    // 1) Hard boundary clamp (100% no outside)
    let d = sdfShape(shape, ball.x, ball.y, R);
    if (d > -ball.r){
      // push inward along gradient
      const {gx,gy} = gradSdf(shape, ball.x, ball.y, R);
      const push = (d + ball.r) + 0.5;
      ball.x -= gx * push;
      ball.y -= gy * push;
      // damp
      ball.vx *= 0.4; ball.vy *= 0.4;
    }

    // 2) Ring walls (bands of SDF offsets) with angular cutouts
    // spacing computed from R and ring count (uniform distance-field spacing)
    ringSpacing = (R - 40) / (rings + 1);
    const w = wallT;
    for(let i=1;i<=rings;i++){
      const target = -i * ringSpacing; // contour where sdf == target
      d = sdfShape(shape, ball.x, ball.y, R);
      const band = Math.abs(d - target);
      if (band < (w/2 + ball.r*0.55)){
        // check cutout at this ring by angle
        const ang = Math.atan2(ball.y, ball.x);
        const co = cutouts[i-1];
        let da = Math.atan2(Math.sin(ang - co.a), Math.cos(ang - co.a)); // shortest delta
        const inCut = Math.abs(da) < (co.w/2);
        if (!inCut){
          // push out of wall band along sdf gradient
          const {gx,gy} = gradSdf(shape, ball.x, ball.y, R);
          // move to nearest side of band
          const sign = (d > target) ? 1 : -1;
          const push = (w/2 + ball.r*0.6) - band + 0.6;
          ball.x += gx * push * sign;
          ball.y += gy * push * sign;
          ball.vx *= 0.55; ball.vy *= 0.55;
        }
      }
    }
  }

  // Win: reach center zone
  function checkWin(){
    const rr = Math.hypot(ball.x, ball.y);
    return rr < 18;
  }

  // ---------- Render ----------
  function draw(shape, R){
    ctx.clearRect(0,0,cv.clientWidth,cv.clientHeight);
    ctx.save();
    ctx.translate(cv.clientWidth/2, cv.clientHeight/2);

    // background vignette
    const g = ctx.createRadialGradient(0,0,20,0,0,R*1.35);
    g.addColorStop(0,"#1a1a1a"); g.addColorStop(1,"#0f0f0f");
    ctx.fillStyle = g; ctx.fillRect(-cv.clientWidth/2,-cv.clientHeight/2,cv.clientWidth,cv.clientHeight);

    const chamfer = +chamferEl.value;

    // outer base
    ctx.fillStyle = "#1c1c1c";
    pathBoundary(shape, R+18, chamfer);
    ctx.fill();

    // boundary stroke
    ctx.strokeStyle = "#3a3a3a";
    ctx.lineWidth = 2;
    pathBoundary(shape, R, chamfer);
    ctx.stroke();

    // rings (draw using contour sampling for visuals)
    ringSpacing = (R - 40) / (rings + 1);
    for(let i=1;i<=rings;i++){
      const target = -i * ringSpacing;
      // draw ring band by marching angle points
      const steps = 220;
      ctx.beginPath();
      for(let s=0;s<=steps;s++){
        const ang = (s/steps)*Math.PI*2;
        // find point on contour along ray by binary search t
        let lo=0, hi=R*1.4;
        for(let it=0;it<18;it++){
          const mid = (lo+hi)/2;
          const x = Math.cos(ang)*mid;
          const y = Math.sin(ang)*mid;
          const d = sdfShape(shape,x,y,R);
          if (d > target) hi = mid; else lo = mid;
        }
        const r = (lo+hi)/2;
        const x = Math.cos(ang)*r, y = Math.sin(ang)*r;
        if (s===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();

      // cutout mask: we "erase" by drawing over background on that arc region (cheap)
      ctx.strokeStyle = "#2f2f2f";
      ctx.lineWidth = wallT;
      ctx.lineCap = "round";
      ctx.stroke();

      // "erase" cutout segment
      const co = cutouts[i-1];
      ctx.save();
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      // approximate arc erase by sampling along angles and stroking with thicker line
      const a0 = co.a - co.w/2, a1 = co.a + co.w/2;
      const steps2 = 60;
      for(let s=0;s<=steps2;s++){
        const ang = a0 + (s/steps2)*(a1-a0);
        let lo=0, hi=R*1.4;
        for(let it=0;it<16;it++){
          const mid=(lo+hi)/2;
          const x=Math.cos(ang)*mid, y=Math.sin(ang)*mid;
          const d=sdfShape(shape,x,y,R);
          if (d > target) hi=mid; else lo=mid;
        }
        const r=(lo+hi)/2;
        const x=Math.cos(ang)*r, y=Math.sin(ang)*r;
        if (s===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.strokeStyle = "#000";
      ctx.lineWidth = wallT + 6;
      ctx.stroke();
      ctx.restore();
    }

    // center target
    ctx.fillStyle = "#1b1b1b";
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#5a5a5a"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.stroke();

    // ball
    const bg = ctx.createRadialGradient(ball.x-4, ball.y-6, 2, ball.x, ball.y, ball.r+6);
    bg.addColorStop(0,"#fff1b8");
    bg.addColorStop(1,"#caa93b");
    ctx.fillStyle = bg;
    ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#5b4b15"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.stroke();

    ctx.restore();
  }

  // ---------- Loop ----------
  let last = performance.now();
  function tick(t){
    const dt = Math.min(0.02, (t-last)/1000); last = t;

    updateKeys();
    const ax = (tiltX*0.9 + keyX*0.85) * 950;
    const ay = (tiltY*0.9 + keyY*0.85) * 950;

    tiltTxt.textContent = `${(tiltX*10).toFixed(1)},${(tiltY*10).toFixed(1)}`;

    // integrate
    ball.vx += ax*dt;
    ball.vy += ay*dt;
    // friction
    ball.vx *= (1 - 3.2*dt);
    ball.vy *= (1 - 3.2*dt);

    ball.x += ball.vx*dt;
    ball.y += ball.vy*dt;

    // boundary based on screen
    const R = Math.min(cv.clientWidth, cv.clientHeight)*0.38;

    applyCollisions(shape, R);

    // Win -> auto next (fast)
    if (checkWin()){
      // tiny celebration: quick impulse + next
      ball.vx = 0; ball.vy = 0;
      if (navigator.vibrate) navigator.vibrate(20);
      level = Math.min(30, level+1);
      regenMaze();
    }

    draw(shape, R);
    requestAnimationFrame(tick);
  }

  regenMaze();
  requestAnimationFrame(tick);

  // Touch drag = manual tilt assist (for testing)
  let dragging=false, sx=0, sy=0;
  cv.addEventListener('pointerdown', (e)=>{ dragging=true; sx=e.clientX; sy=e.clientY; });
  cv.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx = (e.clientX - sx)/150;
    const dy = (e.clientY - sy)/150;
    tiltX = Math.max(-1,Math.min(1,dx));
    tiltY = Math.max(-1,Math.min(1,dy));
  });
  window.addEventListener('pointerup', ()=> dragging=false);

})();
</script>
</body>
</html>
