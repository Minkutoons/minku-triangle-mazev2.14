<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Pixel Rings v2.1 (Tight Lanes + Center + Cutouts)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#111; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { position:fixed; inset:0; touch-action:none; }
    #ui {
      position: fixed; left: 10px; right: 10px; bottom: 10px;
      background: rgba(0,0,0,0.55); color: #fff;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 14px; padding: 10px;
      backdrop-filter: blur(6px);
      display: grid; gap: 8px;
      z-index: 5;
    }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    label { font-size: 12px; opacity: 0.9; display:flex; justify-content:space-between; gap:8px; width: 100%; }
    input[type="range"] { width: 100%; }
    button {
      background:#1e88e5; color:#fff; border:none; border-radius: 12px; padding: 10px 12px;
      font-weight: 700; cursor:pointer;
    }
    button.secondary { background:#2e2e2e; }
    #hint {
      position: fixed; top: 10px; left: 10px; right: 10px;
      color: rgba(255,255,255,0.9);
      font-size: 13px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      pointer-events:none;
      z-index: 6;
    }
  </style>
</head>
<body>
  <div id="hint">
    <b>v2.1:</b> tighter lanes (~2×ball), center marker, and ring cutouts (gates).
  </div>

  <canvas id="world"></canvas>
  <canvas id="overlay"></canvas>

  <div id="ui">
    <div class="row">
      <button id="btnDraw" class="secondary">Draw Mode</button>
      <button id="btnBuild">Build Rings</button>
      <button id="btnReset" class="secondary">Reset</button>
      <button id="btnTilt" class="secondary">Enable Tilt</button>
    </div>

    <div class="row">
      <div style="flex:1 1 220px;">
        <label>Ball Size <span id="vBall">24</span></label>
        <input id="ballD" type="range" min="12" max="48" step="1" value="24">
      </div>
      <div style="flex:1 1 220px;">
        <label>Wall Thickness <span id="vWall">12</span></label>
        <input id="wallT" type="range" min="6" max="26" step="1" value="12">
      </div>
      <div style="flex:1 1 220px;">
        <label>Rings (max) <span id="vRings">12</span></label>
        <input id="maxRings" type="range" min="1" max="20" step="1" value="12">
      </div>
    </div>

    <div class="row">
      <div style="flex:1 1 220px;">
        <label>Balls <span id="vCount">4</span></label>
        <input id="ballN" type="range" min="1" max="10" step="1" value="4">
      </div>
      <div style="flex:1 1 220px;">
        <label>Gravity <span id="vG">1.0</span></label>
        <input id="grav" type="range" min="0.3" max="2.5" step="0.1" value="1.0">
      </div>
      <div style="flex:1 1 220px;">
        <label>Pixel Grid <span id="vGrid">320</span></label>
        <input id="gridN" type="range" min="192" max="512" step="64" value="320">
      </div>
    </div>

    <div class="row">
      <div style="flex:1 1 220px;">
        <label>Gate Size (min 2×ball) <span id="vGate">48</span></label>
        <input id="gateW" type="range" min="24" max="160" step="2" value="48">
      </div>
      <div style="flex:1 1 220px;">
        <label>Center Radius <span id="vCenter">48</span></label>
        <input id="centerR" type="range" min="20" max="140" step="2" value="48">
      </div>
      <div style="flex:1 1 220px;">
        <label>Gate Spread <span id="vSpread">180°</span></label>
        <input id="gateSpread" type="range" min="90" max="180" step="5" value="180">
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
    const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);

    const worldCanvas = document.getElementById('world');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');

    function resizeCanvases() {
      const dpr = window.devicePixelRatio || 1;
      for (const c of [worldCanvas, overlay]) {
        c.width = Math.floor(window.innerWidth * dpr);
        c.height = Math.floor(window.innerHeight * dpr);
        c.style.width = window.innerWidth + 'px';
        c.style.height = window.innerHeight + 'px';
      }
      octx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resizeCanvases);
    resizeCanvases();

    const el = {
      btnDraw: document.getElementById('btnDraw'),
      btnBuild: document.getElementById('btnBuild'),
      btnReset: document.getElementById('btnReset'),
      btnTilt: document.getElementById('btnTilt'),
      ballD: document.getElementById('ballD'),
      wallT: document.getElementById('wallT'),
      maxRings: document.getElementById('maxRings'),
      ballN: document.getElementById('ballN'),
      grav: document.getElementById('grav'),
      gridN: document.getElementById('gridN'),
      gateW: document.getElementById('gateW'),
      centerR: document.getElementById('centerR'),
      gateSpread: document.getElementById('gateSpread'),
      vBall: document.getElementById('vBall'),
      vWall: document.getElementById('vWall'),
      vRings: document.getElementById('vRings'),
      vCount: document.getElementById('vCount'),
      vG: document.getElementById('vG'),
      vGrid: document.getElementById('vGrid'),
      vGate: document.getElementById('vGate'),
      vCenter: document.getElementById('vCenter'),
      vSpread: document.getElementById('vSpread')
    };
    function syncLabels() {
      el.vBall.textContent = el.ballD.value;
      el.vWall.textContent = el.wallT.value;
      el.vRings.textContent = el.maxRings.value;
      el.vCount.textContent = el.ballN.value;
      el.vG.textContent = Number(el.grav.value).toFixed(1);
      el.vGrid.textContent = el.gridN.value;
      // Gate width can't be less than 2×ball
      const minGate = 2 * Number(el.ballD.value);
      if (Number(el.gateW.value) < minGate) el.gateW.value = String(minGate);
      el.vGate.textContent = el.gateW.value;
      el.vCenter.textContent = el.centerR.value;
      el.vSpread.textContent = el.gateSpread.value + "°";
    }
    ['input','change'].forEach(evt => {
      el.ballD.addEventListener(evt, syncLabels);
      el.wallT.addEventListener(evt, syncLabels);
      el.maxRings.addEventListener(evt, syncLabels);
      el.ballN.addEventListener(evt, syncLabels);
      el.grav.addEventListener(evt, syncLabels);
      el.gridN.addEventListener(evt, syncLabels);
      el.gateW.addEventListener(evt, syncLabels);
      el.centerR.addEventListener(evt, syncLabels);
      el.gateSpread.addEventListener(evt, syncLabels);
    });
    syncLabels();

    const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;
    const engine = Engine.create();
    engine.gravity.scale = 0.001;

    const render = Render.create({
      canvas: worldCanvas,
      engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: '#141414',
        pixelRatio: window.devicePixelRatio || 1
      }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    const COLORS = { wallA:'#e53935', wallB:'#b71c1c', ball:'#ffd54f', center:'#8bc34a' };
    let wallBodies = [];
    let ballBodies = [];
    let centerPoint = null;

    function clearWorld() {
      for (const b of wallBodies) World.remove(engine.world, b);
      for (const b of ballBodies) World.remove(engine.world, b);
      wallBodies = [];
      ballBodies = [];
      centerPoint = null;
    }

    function addSegmentWall(p1, p2, thickness, color) {
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const len = Math.hypot(dx,dy);
      if (len < 2) return null;
      const mid = { x: (p1.x+p2.x)/2, y: (p1.y+p2.y)/2 };
      const angle = Math.atan2(dy,dx);
      const rect = Bodies.rectangle(mid.x, mid.y, len, thickness, {
        isStatic: true, friction: 0.2, restitution: 0.1,
        render: { fillStyle: color }
      });
      Body.setAngle(rect, angle);
      return rect;
    }

    function wallsFromPolylineWithGates(poly, thickness, color, gateCenters, gateWidthPx) {
      // Skip wall segments whose midpoint is within gateWidth/2 of any gate center (in screen px).
      const bodies = [];
      const half = gateWidthPx / 2;
      for (let i=0;i<poly.length;i++){
        const a = poly[i], b = poly[(i+1)%poly.length];
        const mid = { x: (a.x+b.x)/2, y: (a.y+b.y)/2 };
        let skip = false;
        for (const gc of gateCenters) {
          if (dist(mid, gc) <= half) { skip = true; break; }
        }
        if (skip) continue;
        const w = addSegmentWall(a,b,thickness,color);
        if (w) bodies.push(w);
      }
      return bodies;
    }

    // -------- Drawing --------
    let ui = { drawMode:true, tiltEnabled:false, tiltX:0, tiltY:0 };
    let rawStroke = [];
    let boundaryPoly = null;

    function getPointerPos(e) {
      const rect = overlay.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function drawOverlayPath(points, closed=false) {
      octx.clearRect(0,0,overlay.width,overlay.height);
      if (!points || points.length < 2) return;
      octx.save();
      octx.lineWidth = 3;
      octx.strokeStyle = 'rgba(255,255,255,0.85)';
      octx.fillStyle = 'rgba(255,255,255,0.07)';
      octx.beginPath();
      octx.moveTo(points[0].x, points[0].y);
      for (let i=1;i<points.length;i++) octx.lineTo(points[i].x, points[i].y);
      if (closed) octx.closePath();
      octx.stroke();
      if (closed) octx.fill();
      octx.restore();
    }

    function drawCenterMarker() {
      if (!centerPoint) return;
      const R = Number(el.centerR.value);
      octx.save();
      octx.beginPath();
      octx.arc(centerPoint.x, centerPoint.y, R, 0, Math.PI*2);
      octx.strokeStyle = 'rgba(139,195,74,0.9)';
      octx.lineWidth = 4;
      octx.stroke();
      octx.fillStyle = 'rgba(139,195,74,0.12)';
      octx.fill();
      octx.restore();
    }

    function simplifyByDistance(points, minStep) {
      if (points.length < 3) return points.slice();
      const out = [points[0]];
      for (let i=1;i<points.length;i++){
        if (dist(points[i], out[out.length-1]) >= minStep) out.push(points[i]);
      }
      return out;
    }

    function fitToScreen(pts, margin=26) {
      const W = window.innerWidth, H = window.innerHeight;
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const p of pts){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
      const bw = Math.max(1, maxX-minX), bh = Math.max(1, maxY-minY);
      const targetW = W - margin*2, targetH = H - margin*2;
      const s = Math.min(targetW/bw, targetH/bh);
      const cx = (minX+maxX)/2, cy = (minY+maxY)/2;
      const tx = W/2, ty = H/2;
      return pts.map(p => ({ x: (p.x-cx)*s + tx, y: (p.y-cy)*s + ty }));
    }

    let isDrawing = false;
    function startDraw(e){
      if (!ui.drawMode) return;
      isDrawing = true;
      rawStroke = [getPointerPos(e)];
      drawOverlayPath(rawStroke,false);
    }
    function moveDraw(e){
      if (!ui.drawMode || !isDrawing) return;
      const p = getPointerPos(e);
      const last = rawStroke[rawStroke.length-1];
      if (!last || dist(p,last) > 2) rawStroke.push(p);
      drawOverlayPath(rawStroke,false);
    }
    function endDraw(){
      if (!ui.drawMode || !isDrawing) return;
      isDrawing = false;
      if (rawStroke.length < 10) { boundaryPoly=null; octx.clearRect(0,0,overlay.width,overlay.height); return; }
      const D = Number(el.ballD.value);
      const minStep = Math.max(3, D/3);
      let pts = simplifyByDistance(rawStroke, minStep);
      pts = fitToScreen(pts, 26);
      boundaryPoly = pts;
      drawOverlayPath(boundaryPoly,true);
    }

    overlay.addEventListener('mousedown', startDraw);
    overlay.addEventListener('mousemove', moveDraw);
    window.addEventListener('mouseup', endDraw);
    overlay.addEventListener('touchstart', (e)=>{ e.preventDefault(); startDraw(e); }, {passive:false});
    overlay.addEventListener('touchmove', (e)=>{ e.preventDefault(); moveDraw(e); }, {passive:false});
    overlay.addEventListener('touchend', (e)=>{ e.preventDefault(); endDraw(); }, {passive:false});

    // -------- Pixel grid + masks --------
    function makeGrid(N) {
      const W = window.innerWidth, H = window.innerHeight;
      const scale = Math.min(W, H) / N;
      const offsetX = (W - N*scale)/2;
      const offsetY = (H - N*scale)/2;
      return {
        N, scale, offsetX, offsetY,
        toGrid: (x,y) => ({
          gx: clamp(Math.floor((x - offsetX)/scale), 0, N-1),
          gy: clamp(Math.floor((y - offsetY)/scale), 0, N-1)
        }),
        toScreen: (gx,gy) => ({
          x: offsetX + (gx + 0.5)*scale,
          y: offsetY + (gy + 0.5)*scale
        })
      };
    }

    function rasterizePolygonToMask(poly, grid) {
      const N = grid.N;
      const off = document.createElement('canvas');
      off.width = N; off.height = N;
      const ctx = off.getContext('2d');
      ctx.clearRect(0,0,N,N);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      const p0 = grid.toGrid(poly[0].x, poly[0].y);
      ctx.moveTo(p0.gx+0.5, p0.gy+0.5);
      for (let i=1;i<poly.length;i++){
        const gp = grid.toGrid(poly[i].x, poly[i].y);
        ctx.lineTo(gp.gx+0.5, gp.gy+0.5);
      }
      ctx.closePath();
      ctx.fill();
      const img = ctx.getImageData(0,0,N,N).data;
      const mask = new Uint8Array(N*N);
      for (let i=0;i<N*N;i++) mask[i] = img[i*4+3] > 0 ? 1 : 0;
      return mask;
    }

    function subtractMask(a,b) {
      const out = new Uint8Array(a.length);
      for (let i=0;i<a.length;i++) out[i] = (a[i]===1 && b[i]===0) ? 1 : 0;
      return out;
    }

    function erodeMask(mask, N, r) {
      if (r <= 0) return mask.slice();
      const out = new Uint8Array(N*N);
      for (let y=0;y<N;y++){
        for (let x=0;x<N;x++){
          const idx = y*N+x;
          if (mask[idx] === 0) { out[idx]=0; continue; }
          let ok = 1;
          const y0 = Math.max(0, y-r), y1 = Math.min(N-1, y+r);
          const x0 = Math.max(0, x-r), x1 = Math.min(N-1, x+r);
          for (let yy=y0; yy<=y1 && ok; yy++){
            const row = yy*N;
            for (let xx=x0; xx<=x1; xx++){
              if (mask[row+xx] === 0) { ok = 0; break; }
            }
          }
          out[idx] = ok;
        }
      }
      return out;
    }

    function largestComponentMask(mask, N) {
      const seen = new Uint8Array(N*N);
      let bestSize = 0, best = null;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (let i=0;i<N*N;i++){
        if (mask[i]===0 || seen[i]) continue;
        const q = [i];
        seen[i]=1;
        const comp = [i];
        while(q.length){
          const v = q.pop();
          const x = v % N, y = (v / N) | 0;
          for (const [dx,dy] of dirs){
            const nx = x+dx, ny = y+dy;
            if (nx<0||nx>=N||ny<0||ny>=N) continue;
            const ni = ny*N+nx;
            if (mask[ni]===1 && !seen[ni]) { seen[ni]=1; q.push(ni); comp.push(ni); }
          }
        }
        if (comp.length > bestSize) { bestSize = comp.length; best = comp; }
      }
      if (!best) return mask;
      const out = new Uint8Array(N*N);
      for (const idx of best) out[idx]=1;
      return out;
    }

    function centroidOfMask(mask, N, grid) {
      let sx=0, sy=0, c=0;
      for (let y=0;y<N;y++){
        for (let x=0;x<N;x++){
          if (mask[y*N+x]===1) { sx += x; sy += y; c++; }
        }
      }
      if (c === 0) return { x: window.innerWidth/2, y: window.innerHeight/2 };
      const gx = sx / c;
      const gy = sy / c;
      return grid.toScreen(gx, gy);
    }

    function traceBoundaryFromMask(mask, N) {
      const isBoundary = (x,y) => {
        const idx = y*N+x;
        if (mask[idx]===0) return false;
        if (x===0||y===0||x===N-1||y===N-1) return true;
        return (mask[idx-1]===0 || mask[idx+1]===0 || mask[idx-N]===0 || mask[idx+N]===0);
      };

      let sx=-1, sy=-1;
      outer:
      for (let y=0;y<N;y++){
        for (let x=0;x<N;x++){
          if (isBoundary(x,y)) { sx=x; sy=y; break outer; }
        }
      }
      if (sx<0) return [];

      const dirs = [[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]];
      let x=sx, y=sy;
      let px=sx-1, py=sy;
      const poly = [];
      const visited = new Set();
      const edgeKey = (ax,ay,bx,by)=> ax+','+ay+'|'+bx+','+by;

      for (let iter=0; iter < N*N*4; iter++){
        poly.push({x,y});
        let startDir = 0;
        for (let d=0; d<8; d++){
          if (x + dirs[d][0] === px && y + dirs[d][1] === py) { startDir = (d+1)%8; break; }
        }
        let found=false;
        for (let k=0;k<8;k++){
          const d = (startDir + k) % 8;
          const nx = x + dirs[d][0], ny = y + dirs[d][1];
          if (nx<0||nx>=N||ny<0||ny>=N) continue;
          if (mask[ny*N+nx] === 1) {
            const ek = edgeKey(x,y,nx,ny);
            if (visited.has(ek) && Math.hypot(nx-sx, ny-sy) < 2 && iter>10) return poly;
            visited.add(ek);
            px=x; py=y; x=nx; y=ny;
            found=true;
            break;
          }
        }
        if (!found) break;
        if (x===sx && y===sy && iter>10) break;
      }
      return poly;
    }

    function decimatePolyline(poly, step) {
      if (poly.length < 3) return poly;
      const out = [poly[0]];
      let acc = 0;
      for (let i=1;i<poly.length;i++){
        acc += dist(poly[i], poly[i-1]);
        if (acc >= step) { out.push(poly[i]); acc = 0; }
      }
      return out.length >= 3 ? out : poly;
    }

    function smoothPolyline(poly, passes=2) {
      if (poly.length < 5) return poly;
      let p = poly.slice();
      for (let t=0;t<passes;t++){
        const q = [];
        for (let i=0;i<p.length;i++){
          const a = p[(i-1+p.length)%p.length];
          const b = p[i];
          const c = p[(i+1)%p.length];
          q.push({ x: (a.x + b.x*2 + c.x)/4, y: (a.y + b.y*2 + c.y)/4 });
        }
        p = q;
      }
      return p;
    }

    function pickGateCenters(poly, center, gateCount, spreadDeg) {
      // Pick gate centers on polyline using farthest-from-center candidates, enforcing angular separation.
      const candidates = poly.map(p => {
        const ang = Math.atan2(p.y - center.y, p.x - center.x);
        const r = Math.hypot(p.x - center.x, p.y - center.y);
        return { p, ang, r };
      }).sort((a,b)=> b.r - a.r); // widest areas first

      const chosen = [];
      const minSep = (spreadDeg * Math.PI / 180) * (gateCount === 1 ? 0 : 0.9); // keep wide apart
      function angDiff(a,b){
        let d = Math.abs(a-b);
        while (d > Math.PI) d = Math.abs(d - 2*Math.PI);
        return d;
      }

      for (const c of candidates) {
        if (!chosen.length) { chosen.push(c); if (chosen.length===gateCount) break; continue; }
        let ok = true;
        for (const ch of chosen) {
          if (angDiff(c.ang, ch.ang) < minSep) { ok = false; break; }
        }
        if (ok) chosen.push(c);
        if (chosen.length === gateCount) break;
      }

      // If not enough, fall back to opposite angles
      if (chosen.length < gateCount && poly.length) {
        const base = chosen[0]?.ang ?? 0;
        while (chosen.length < gateCount) {
          const target = base + Math.PI;
          // find closest point by angle
          let best = candidates[0];
          let bestD = 1e9;
          for (const c of candidates.slice(0, Math.min(400, candidates.length))) {
            const d = angDiff(c.ang, target);
            if (d < bestD) { bestD = d; best = c; }
          }
          chosen.push(best);
        }
      }
      return chosen.map(x => x.p);
    }

    function spawnBallsInRing(ringMask, grid) {
      const D = Number(el.ballD.value);
      const r = D/2;
      const nBalls = Number(el.ballN.value);
      const N = grid.N;

      const candidates = [];
      for (let y=0;y<N;y+=2){
        for (let x=0;x<N;x+=2){
          if (ringMask[y*N+x] === 1) candidates.push({x,y});
        }
      }
      if (candidates.length < 50) return;
      candidates.sort((a,b)=> (a.x+a.y) - (b.x+b.y));
      const pick = candidates[Math.floor(candidates.length*0.03)] || candidates[0];
      const base = grid.toScreen(pick.x, pick.y);

      for (let i=0;i<nBalls;i++){
        const b = Bodies.circle(base.x + i*(D*1.05), base.y + i*(D*0.6), r, {
          friction: 0.02, frictionAir: 0.006, restitution: 0.15, density: 0.002,
          render: { fillStyle: COLORS.ball }
        });
        ballBodies.push(b);
        World.add(engine.world, b);
      }
    }

    function buildPixelRings() {
      if (!boundaryPoly || boundaryPoly.length < 5) return;
      clearWorld();

      const N = Number(el.gridN.value);
      const grid = makeGrid(N);

      const D = Number(el.ballD.value);
      const T = Number(el.wallT.value);
      const maxR = Number(el.maxRings.value);
      const laneWidthPx = 2 * D; // target
      const gateWidthPx = Math.max(2*D, Number(el.gateW.value));
      const spreadDeg = Number(el.gateSpread.value);

      const cellPx = grid.scale;
      const toRadFloor = (px) => Math.max(1, Math.floor(px / cellPx));

      // NEW: separate lane and wall steps to stop over-wide lanes
      const laneR = toRadFloor(laneWidthPx);
      const wallR = toRadFloor(T);

      // Rasterize outer boundary
      let m0 = rasterizePolygonToMask(boundaryPoly, grid);
      m0 = largestComponentMask(m0, N);

      // Safe margin so ball center won't touch outermost boundary wall
      const safeMarginPx = (T/2) + (D/2) + 2;
      let mCurr = erodeMask(m0, N, toRadFloor(safeMarginPx));
      mCurr = largestComponentMask(mCurr, N);

      // Center for gate angles: use centroid of current playable region
      const center = centroidOfMask(mCurr, N, grid);
      centerPoint = center;

      // Draw boundary + center marker
      drawOverlayPath(boundaryPoly,true);
      drawCenterMarker();

      // Build outer wall once (no gates)
      // outer wall boundary from mCurr
      const outerPix0 = traceBoundaryFromMask(mCurr, N);
      if (outerPix0.length < 40) return;
      const outerPoly0 = smoothPolyline(decimatePolyline(outerPix0, 2), 2).map(p => grid.toScreen(p.x, p.y));
      wallBodies.push(...wallsFromPolylineWithGates(outerPoly0, T, COLORS.wallA, [], 0));

      let firstRingMask = null;

      for (let k=0; k<maxR; k++){
        // Inner boundary of lane (controls corridor width)
        let mLaneInner = erodeMask(mCurr, N, laneR);
        mLaneInner = largestComponentMask(mLaneInner, N);

        // Ring area for spawning (corridor pixels)
        const ringMask = subtractMask(mCurr, mLaneInner);

        let ringCount = 0;
        for (let i=0;i<ringMask.length;i++) ringCount += ringMask[i];
        if (ringCount < N*N*0.002) break;

        // Determine if there will be another ring beyond this wall
        let mNextStart = erodeMask(mLaneInner, N, wallR);
        mNextStart = largestComponentMask(mNextStart, N);

        // If next region too small, this is innermost ring -> 1 gate into center
        let nextCount = 0;
        for (let i=0;i<mNextStart.length;i++) nextCount += mNextStart[i];
        const isInnermost = nextCount < N*N*0.004;

        const gateCount = isInnermost ? 1 : 2;

        // Wall boundary between this ring and next: mLaneInner boundary
        const wallPix = traceBoundaryFromMask(mLaneInner, N);
        if (wallPix.length < 40) break;
        const wallPoly = smoothPolyline(decimatePolyline(wallPix, 2), 2).map(p => grid.toScreen(p.x, p.y));

        // Pick gate centers on that wall boundary
        const gateCenters = pickGateCenters(wallPoly, center, gateCount, spreadDeg);

        const col = (k % 2 === 0) ? COLORS.wallB : COLORS.wallA;
        wallBodies.push(...wallsFromPolylineWithGates(wallPoly, T, col, gateCenters, gateWidthPx));

        if (k === 0) firstRingMask = ringMask;

        // Advance: start next ring corridor outer boundary is mNextStart
        mCurr = mNextStart;

        // Stop if we're too small
        if (isInnermost) break;
      }

      World.add(engine.world, wallBodies);
      if (firstRingMask) spawnBallsInRing(firstRingMask, grid);
    }

    // -------- Tilt --------
    function applyGravity(){
      const gScale = Number(el.grav.value);
      engine.gravity.x = ui.tiltX * gScale;
      engine.gravity.y = ui.tiltY * gScale;
    }

    async function enableTilt() {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== 'granted') throw new Error('Permission denied');
      }
      ui.tiltEnabled = true;
    }

    window.addEventListener('deviceorientation', (e) => {
      if (!ui.tiltEnabled) return;
      const gamma = e.gamma || 0;
      const beta  = e.beta  || 0;
      ui.tiltX = clamp(gamma / 30, -1, 1);
      ui.tiltY = clamp(beta  / 30, -1, 1);
      applyGravity();
    }, true);

    const keys = {ArrowLeft:false, ArrowRight:false, ArrowUp:false, ArrowDown:false};
    window.addEventListener('keydown', (e)=>{ if (e.key in keys) keys[e.key]=true; });
    window.addEventListener('keyup', (e)=>{ if (e.key in keys) keys[e.key]=false; });
    Events.on(engine, 'beforeUpdate', () => {
      if (!ui.tiltEnabled) {
        const tx = (keys.ArrowRight?1:0) - (keys.ArrowLeft?1:0);
        const ty = (keys.ArrowDown?1:0) - (keys.ArrowUp?1:0);
        ui.tiltX = tx * 0.7;
        ui.tiltY = ty * 0.7;
        applyGravity();
      }
    });

    // -------- Buttons --------
    el.btnDraw.onclick = () => {
      ui.drawMode = !ui.drawMode;
      el.btnDraw.textContent = ui.drawMode ? 'Draw Mode' : 'Play Mode';
      el.btnDraw.classList.toggle('secondary', ui.drawMode);
      if (!ui.drawMode) octx.clearRect(0,0,overlay.width,overlay.height);
      else { if (boundaryPoly) drawOverlayPath(boundaryPoly,true); drawCenterMarker(); }
    };

    el.btnBuild.onclick = () => buildPixelRings();

    el.btnReset.onclick = () => {
      boundaryPoly = null;
      rawStroke = [];
      octx.clearRect(0,0,overlay.width,overlay.height);
      clearWorld();
    };

    el.btnTilt.onclick = async () => {
      try {
        await enableTilt();
        el.btnTilt.textContent = 'Tilt Enabled';
        el.btnTilt.disabled = true;
      } catch (err) {
        alert('Tilt permission failed. On iPhone: Settings > Safari > Motion & Orientation Access.');
      }
    };
  </script>
</body>
</html>
