<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Rock n Roll: Ball Maze Challenge ‚Äì Minku (Theme + 4 Balls)</title>
<style>
  :root{
    --bg0:#0b0d12;
    --bg1:#111428;
    --panel: rgba(18,22,34,.88);
    --panel2: rgba(24,30,48,.88);
    --text:#eef2ff;
    --muted:#b9c0d8;
    --border: rgba(255,255,255,.12);
    --shadow: 0 14px 40px rgba(0,0,0,.45);
  }
  html,body{
    margin:0;height:100%;
    background: radial-gradient(1200px 700px at 20% -10%, rgba(120,166,255,.22), transparent 55%),
                radial-gradient(1100px 650px at 90% 20%, rgba(255,122,162,.14), transparent 58%),
                radial-gradient(900px 600px at 40% 110%, rgba(255,209,102,.12), transparent 60%),
                linear-gradient(180deg,var(--bg1),var(--bg0));
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    overflow:hidden;
  }
  #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
  #top{
    display:flex; gap:10px; align-items:center; justify-content:space-between;
    padding:10px 12px;
    background: linear-gradient(180deg, rgba(18,22,34,.95), rgba(18,22,34,.70));
    border-bottom:1px solid var(--border);
    backdrop-filter: blur(10px);
  }
  .left,.right{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{
    background: var(--panel);
    border:1px solid var(--border);
    border-radius:999px;
    padding:7px 10px;
    font-size:12px;
    color:var(--muted);
    box-shadow: var(--shadow);
  }
  .pill b{color:var(--text)}
  .btn{
    background: var(--panel2);
    border:1px solid var(--border);
    border-radius:12px;
    padding:8px 10px;
    color:var(--text);
    font-weight:700;
    cursor:pointer;
    box-shadow: var(--shadow);
  }
  .btn:active{transform:translateY(1px)}
  .btn.primary{border-color: rgba(255,209,102,.35); background: rgba(255,209,102,.12); color:#ffe7a5}
  .slider{display:flex;gap:8px;align-items:center}
  input[type=range]{width:120px}
  #cv{flex:1;display:block;touch-action:none}
  #bottomHint{
    position:fixed;left:12px;right:12px;bottom:10px;
    display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
    color:#cbd3ee;font-size:12px;opacity:.95;
    pointer-events:none;
    text-shadow: 0 1px 0 rgba(0,0,0,.35);
  }
  .miniPill{
    pointer-events:none;
    background: rgba(18,22,34,.55);
    border:1px solid rgba(255,255,255,.10);
    border-radius:999px;
    padding:6px 10px;
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="top">
    <div class="left">
      <div class="pill"><b>Rock n Roll</b> ‚Ä¢ Minku ‚Ä¢ <span id="themeName">Festival</span></div>
      <div class="pill" id="status">L1 ‚Ä¢ TRIANGLE ‚Ä¢ Circle üîí ‚Ä¢ Balls: 4</div>
      <button class="btn" id="restart">Restart</button>
      <button class="btn" id="prev">Prev</button>
      <button class="btn primary" id="next">Next</button>
    </div>
    <div class="right">
      <div class="slider pill">
        Ball D
        <input id="ballD" type="range" min="16" max="34" value="20" />
        <span id="ballDVal" style="opacity:.9">20</span>
      </div>
      <div class="slider pill">
        Gate W (√óD)
        <input id="gateW" type="range" min="2.10" max="2.55" step="0.01" value="2.30" />
        <span id="gateWVal" style="opacity:.9">2.30</span>
      </div>
      <div class="slider pill" title="Polygon junction style (chamfer, not fillet)">
        Chamfer
        <input id="chamfer" type="range" min="0" max="40" value="18" />
      </div>
      <div class="pill">Tilt: <span id="tiltTxt">0,0</span></div>
    </div>
  </div>
  <canvas id="cv"></canvas>
</div>

<div id="bottomHint">
  <div class="miniPill">Tilt phone or use Arrow keys / WASD. Goal: get <b>all 4 balls</b> into center pocket.</div>
  <div class="miniPill">Cutouts are physical (open) ‚Äî if a gate feels ‚Äúbouncy‚Äù, we tune the gate edge & damping.</div>
</div>

<script>
(() => {
  // ========= Locked parameters (gathered & applied) =========
  const LOCKED = {
    balls: 4,
    // Cutout strategy (locked):
    // Rings 1..N-1: two gates A & B; ring N: one gate C.
    // Balance across 4 sectors (square/rect/circle) or 6 sectors (triangle).
    // A/B slot positions inside sector: early 0.28, late 0.72.
    // Gate width is linear = (GateW √ó BallD) so 2 balls fit, 3 don't.
    cutout: {
      sectorsTri: 6,
      sectorsOther: 4,
      slotA: 0.28,
      slotB: 0.72,
      sectorJitter: 0.10,    // angle randomness inside sector
      spiralBase: 0.42,      // ring-to-ring spiral shift base
      spiralJitter: 0.08,    // spiral randomness
      cJitter: 0.15          // last ring C gate jitter
    },
    physics: {
      accel: 0.42,           // tilt acceleration
      friction: 0.985,       // velocity damping
      wallDamp: 0.55,        // wall collision damping
      boundaryDamp: 0.40,    // boundary clamp damping
      maxV: 22               // cap
    }
  };

  // ========= Theme (colorful but not neon) =========
  const THEMES = [
    { name:"Festival", floorA:"#10162b", floorB:"#0b0d12", wall:"#e7f0ff", glow:"rgba(120,166,255,.35)" },
    { name:"Candy",    floorA:"#1b1230", floorB:"#0b0d12", wall:"#ffe6f1", glow:"rgba(255,122,162,.32)" },
    { name:"Mango",    floorA:"#20180b", floorB:"#0b0d12", wall:"#fff0cf", glow:"rgba(255,209,102,.28)" },
    { name:"Ocean",    floorA:"#091a2a", floorB:"#0b0d12", wall:"#d8f2ff", glow:"rgba(76,201,240,.25)" },
  ];
  const BALL_COLORS = ["#78a6ff", "#ff7aa2", "#ffd166", "#4ecdc4"];

  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;};}

  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const statusEl = document.getElementById('status');
  const themeNameEl = document.getElementById('themeName');
  const tiltTxt = document.getElementById('tiltTxt');
  const chamferEl = document.getElementById('chamfer');
  const ballDEl = document.getElementById('ballD');
  const ballDVal = document.getElementById('ballDVal');
  const gateWEl = document.getElementById('gateW');
  const gateWVal = document.getElementById('gateWVal');

  // ---------- Resize ----------
  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
    cv.width = Math.floor(cv.clientWidth * dpr);
    cv.height = Math.floor(cv.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  if (window.ResizeObserver) {
    new ResizeObserver(resize).observe(cv);
  } else {
    window.addEventListener('resize', resize, {passive:true});
  }
  resize();

  // ---------- Input tilt ----------
  let tiltX = 0, tiltY = 0;
  let keyX = 0, keyY = 0;

  window.addEventListener('deviceorientation', (e) => {
    const gx = (e.gamma ?? 0);
    const by = (e.beta ?? 0);
    tiltX = Math.max(-20, Math.min(20, gx)) / 20;
    tiltY = Math.max(-20, Math.min(20, by)) / 20;
  }, {passive:true});

  const keys = new Set();
  window.addEventListener('keydown', (e)=>{ keys.add(e.key.toLowerCase()); });
  window.addEventListener('keyup', (e)=>{ keys.delete(e.key.toLowerCase()); });

  function updateKeys(){
    keyX = 0; keyY = 0;
    if(keys.has('arrowleft') || keys.has('a')) keyX -= 1;
    if(keys.has('arrowright')|| keys.has('d')) keyX += 1;
    if(keys.has('arrowup')   || keys.has('w')) keyY -= 1;
    if(keys.has('arrowdown') || keys.has('s')) keyY += 1;
  }

  // ---------- Level rules ----------
  let level = 1;
  let shape = "triangle";
  let rings = 6;
  let ringSpacing = 28;
  let wallT = 10;
  let cutouts = [];

  function shapeForLevel(L){
    if(L<=1) return "triangle";
    if(L<=2) return "square";
    if(L<=4) return "rect";
    if(L<5)  return (L%2? "square":"triangle");
    return (L%5===0)? "circle" : (L%3===0? "rect":"square");
  }
  function ringCountForLevel(L){
    if (L<=2) return 6;
    if (L<=5) return 7;
    if (L<=10) return 8;
    if (L<=15) return 9;
    return 10;
  }
  function wallThicknessForLevel(L){
    return (L<=5) ? 10 : (L<=12 ? 11 : 12);
  }

  // ---------- SDF shapes ----------
  function sdfTriangle(x,y,R){
    // equilateral triangle (approx) centered at origin
    const k = Math.sqrt(3);
    x = Math.abs(x);
    return Math.max((x*0.5 + k*y*0.5), -y) - R*0.62;
  }
  function sdfSquare(x,y,R){
    const ax=Math.abs(x), ay=Math.abs(y);
    return Math.max(ax,ay) - R*0.70;
  }
  function sdfRect(x,y,R){
    const hx=R*0.78, hy=R*0.56;
    const ax=Math.abs(x)-hx, ay=Math.abs(y)-hy;
    const ox=Math.max(ax,0), oy=Math.max(ay,0);
    return Math.hypot(ox,oy) + Math.min(Math.max(ax,ay),0);
  }
  function sdfCircle(x,y,R){
    return Math.hypot(x,y) - R*0.78;
  }
  function sdfShape(shape,x,y,R){
    if(shape==="triangle") return sdfTriangle(x,y,R);
    if(shape==="square") return sdfSquare(x,y,R);
    if(shape==="rect") return sdfRect(x,y,R);
    return sdfCircle(x,y,R);
  }
  function gradSdf(shape,x,y,R){
    const eps = 0.5;
    const d0 = sdfShape(shape,x,y,R);
    const dx = sdfShape(shape,x+eps,y,R)-d0;
    const dy = sdfShape(shape,x,y+eps,R)-d0;
    const len = Math.hypot(dx,dy) || 1;
    return {gx:dx/len, gy:dy/len};
  }

  // ---------- Maze build (cutouts gathered & applied) ----------
  function wrapAng(a){
    const tau = Math.PI*2;
    a = a % tau;
    return a < 0 ? a + tau : a;
  }

  function buildLevel(){
    shape = shapeForLevel(level);
    rings = ringCountForLevel(level);
    wallT = wallThicknessForLevel(level);

    const seed = 10007*level + (shape.charCodeAt(0)*997) + rings*123;
    const rng = mulberry32(seed);

    const sectorCount = (shape === 'triangle') ? LOCKED.cutout.sectorsTri : LOCKED.cutout.sectorsOther;
    const sectorSize = (Math.PI*2)/sectorCount;

    // Balance quotas across sectors for A/B gates (rings-1, 2 gates each).
    // IMPORTANT: keep angles inside their picked sectors (no spiral drift),
    // otherwise "quarter balance" breaks.
    const totalAB = 2*(rings-1);
    const base = Math.floor(totalAB/sectorCount);
    let rem = totalAB % sectorCount;
    const quota = Array(sectorCount).fill(base);
    for(let i=0;i<sectorCount && rem>0;i++,rem--){
      quota[(i + (level%sectorCount))%sectorCount]++; // rotate by level
    }

    function pickSector(avoidSet){
      // pick the sector with remaining quota, prefer far from avoids
      let best = -1, bestScore = -1;
      for(let s=0;s<sectorCount;s++){
        if(quota[s] <= 0) continue;
        if(avoidSet && avoidSet.has(s)) continue;
        let score = quota[s];
        if(avoidSet && avoidSet.size){
          // distance around circle to nearest avoid
          let minDist = 99;
          for(const a of avoidSet){
            let d = Math.abs(s-a);
            d = Math.min(d, sectorCount-d);
            minDist = Math.min(minDist, d);
          }
          score += minDist * 0.5;
        }
        if(score > bestScore){ bestScore = score; best = s; }
      }
      if(best < 0){
        // fallback: any sector
        for(let s=0;s<sectorCount;s++){ if(quota[s]>0){ best=s; break; } }
        if(best < 0) best = 0;
      }
      quota[best] = Math.max(0, quota[best]-1);
      return best;
    }

    const D = +ballDEl.value;
    const Wmul = +gateWEl.value;
    const wLin = Wmul * D;

    // jitter in radians (scaled by sector size)
    const jitterRad = LOCKED.cutout.sectorJitter * sectorSize;

    cutouts = [];
    for(let i=1;i<=rings;i++){
      const gates = [];
      if (i < rings){
        const avoid = new Set();
        const sA = pickSector(avoid); avoid.add(sA);
        // also try to avoid neighboring sector for B if possible
        avoid.add((sA+1)%sectorCount);
        avoid.add((sA-1+sectorCount)%sectorCount);

        const sB = pickSector(avoid);

        const aA = wrapAng((sA + LOCKED.cutout.slotA) * sectorSize + (rng()*2-1)*jitterRad);
        const aB = wrapAng((sB + LOCKED.cutout.slotB) * sectorSize + (rng()*2-1)*jitterRad);

        gates.push({type:"A", a:aA, wLin});
        gates.push({type:"B", a:aB, wLin});
      } else {
        // last ring: single gate C near the midpoint of previous A & B, with small jitter
        const prev = cutouts[i-2];
        const aA = prev[0].a, aB = prev[1].a;
        let mid = Math.atan2(Math.sin(aA)+Math.sin(aB), Math.cos(aA)+Math.cos(aB));
        mid += (rng()*2-1) * (LOCKED.cutout.cJitter * sectorSize);
        gates.push({type:"C", a:wrapAng(mid), wLin});
      }
      cutouts.push(gates);
    }

    resetBalls();
    updateStatus();
  }

  function updateStatus(){
    const s = shape.toUpperCase();
    const circleLocked = (level<5) ? "Circle üîí" : "Circle ‚úÖ";
    const theme = THEMES[(level-1)%THEMES.length];
    themeNameEl.textContent = theme.name;
    statusEl.textContent = `L${level} ‚Ä¢ ${s} ‚Ä¢ ${circleLocked} ‚Ä¢ Balls: ${LOCKED.balls}`;
  }

  // ---------- Balls (4-ball configuration) ----------
  const balls = Array.from({length: LOCKED.balls}, (_,i)=>({x:0,y:0,vx:0,vy:0,r:10, baseR:10, c:BALL_COLORS[i%BALL_COLORS.length]}));

  function resetBalls(){
    const D = +ballDEl.value;
    const r = D/2;
    // spawn in a neat 2x2 pack, safely inside outer region
    const baseX = -90, baseY = -70;
    const gap = r*2.3;
    for(let i=0;i<balls.length;i++){
      const b = balls[i];
      b.baseR = r; b.r = r;
      b.vx = b.vy = 0;
      const ox = (i%2)*gap;
      const oy = (i>=2)*gap;
      b.x = baseX + ox;
      b.y = baseY + oy;
    }
  }

  // ---------- UI ----------
  document.getElementById('restart').onclick = () => resetBalls();
  document.getElementById('prev').onclick = () => { level = Math.max(1, level-1); buildLevel(); };
  document.getElementById('next').onclick = () => { level = Math.min(30, level+1); buildLevel(); };

  function syncSliders(){
    const D = +ballDEl.value;
    ballDVal.textContent = String(D);
    gateWVal.textContent = (+gateWEl.value).toFixed(2);
    // update all balls radius
    for(const b of balls){ b.baseR = D/2; b.r = D/2; }
  }
  ballDEl.oninput = () => { syncSliders(); buildLevel(); };
  gateWEl.oninput = () => { syncSliders(); buildLevel(); };
  chamferEl.oninput = () => {};

  // ---------- Physics ----------
  function applyBoundary(ball, shape, R){
    let d = sdfShape(shape, ball.x, ball.y, R);
    if (d > -ball.r){
      const {gx,gy} = gradSdf(shape, ball.x, ball.y, R);
      const push = (d + ball.r) + 0.6;
      ball.x -= gx * push;
      ball.y -= gy * push;
      ball.vx *= LOCKED.physics.boundaryDamp;
      ball.vy *= LOCKED.physics.boundaryDamp;
    }
  }

  function applyRings(ball, shape, R){
    ringSpacing = (R - 40) / (rings + 1);
    const w = wallT;
    for(let i=1;i<=rings;i++){
      const target = -i * ringSpacing;
      const d = sdfShape(shape, ball.x, ball.y, R);
      const band = Math.abs(d - target);
      if (band < (w/2 + ball.r*0.55)){
        const ang = Math.atan2(ball.y, ball.x);
        const gates = cutouts[i-1];
        const approxR = Math.max(40, (R - i*ringSpacing));
        let inCut = false;
        for(const g of gates){
          const wAng = g.wLin / approxR;
          const da = Math.atan2(Math.sin(ang - g.a), Math.cos(ang - g.a));
          if (Math.abs(da) < (wAng/2)) { inCut = true; break; }
        }
        if (!inCut){
          const {gx,gy} = gradSdf(shape, ball.x, ball.y, R);
          const sign = (d > target) ? 1 : -1;
          const push = (w/2 + ball.r*0.6) - band + 0.7;
          ball.x += gx * push * sign;
          ball.y += gy * push * sign;
          ball.vx *= LOCKED.physics.wallDamp;
          ball.vy *= LOCKED.physics.wallDamp;
        }
      }
    }
  }

  function resolveBallBall(){
    for(let i=0;i<balls.length;i++){
      for(let j=i+1;j<balls.length;j++){
        const a = balls[i], b = balls[j];
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist = Math.hypot(dx,dy) || 0.0001;
        const minD = a.r + b.r;
        if(dist < minD){
          const nx = dx/dist, ny = dy/dist;
          const overlap = (minD - dist) + 0.5;
          // separate equally
          a.x -= nx * overlap*0.5; a.y -= ny * overlap*0.5;
          b.x += nx * overlap*0.5; b.y += ny * overlap*0.5;

          // simple velocity exchange along normal (stable, arcade-like)
          const relVx = b.vx - a.vx, relVy = b.vy - a.vy;
          const vn = relVx*nx + relVy*ny;
          if(vn < 0){
            const impulse = -vn * 0.7;
            a.vx -= impulse*nx; a.vy -= impulse*ny;
            b.vx += impulse*nx; b.vy += impulse*ny;
          }
        }
      }
    }
  }

  function centerPocketR(){ 
    // spec: innermost ring >= 4 ball dia + 10%
    const r = balls[0].r;
    return r * 4.4;
  }

  function allInPocket(){
    const pr = centerPocketR();
    for(const b of balls){
      if(Math.hypot(b.x,b.y) > pr - b.r*0.5) return false;
    }
    return true;
  }

  // ---------- Draw ----------
  function draw(shape, R){
    const theme = THEMES[(level-1)%THEMES.length];
    const W = cv.clientWidth, H = cv.clientHeight;

    ctx.clearRect(0,0,W,H);

    // Floor
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, theme.floorA);
    g.addColorStop(1, theme.floorB);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // subtle sparkles
    ctx.globalAlpha = 0.16;
    for(let i=0;i<22;i++){
      const x = (Math.sin((i+1)*999)*0.5+0.5)*W;
      const y = (Math.cos((i+1)*777)*0.5+0.5)*H;
      ctx.beginPath();
      ctx.arc(x,y, (i%3)+1, 0, Math.PI*2);
      ctx.fillStyle = (i%2===0) ? theme.glow : "rgba(255,255,255,.18)";
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // center transform
    ctx.save();
    ctx.translate(W/2, H/2);

    // glow ring
    ctx.strokeStyle = theme.glow;
    ctx.lineWidth = wallT*1.2;
    ctx.shadowColor = theme.glow;
    ctx.shadowBlur = 18;

    // draw outer boundary outline (approx by marching angles)
    drawShapeOutline(shape, R, 220);

    // rings
    ctx.shadowBlur = 14;
    ctx.strokeStyle = theme.wall;
    ctx.lineWidth = wallT;

    ringSpacing = (R - 40) / (rings + 1);
    for(let i=1;i<=rings;i++){
      const rr = R - i*ringSpacing;
      drawRingWithGates(shape, rr, i-1);
    }

    // pocket
    ctx.shadowBlur = 16;
    ctx.fillStyle = "rgba(255,255,255,.08)";
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0,0, centerPocketR(), 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // balls
    ctx.shadowBlur = 18;
    for(const b of balls){
      ctx.beginPath();
      ctx.fillStyle = b.c;
      ctx.shadowColor = b.c;
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      // highlight
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(b.x-b.r*0.25, b.y-b.r*0.25, b.r*0.35, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 18;
    }

    ctx.restore();
  }

  function drawShapeOutline(shape, R, steps){
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const a = (i/steps)*Math.PI*2;
      // approximate boundary point by radial search on sdf=0
      const p = pointOnBoundary(shape, a, R);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  function pointOnBoundary(shape, ang, R){
    // binary search radius along angle so sdf ~ 0
    let lo=0, hi=R*1.05;
    for(let k=0;k<18;k++){
      const mid=(lo+hi)/2;
      const x=Math.cos(ang)*mid, y=Math.sin(ang)*mid;
      const d=sdfShape(shape,x,y,R);
      if(d>0) hi=mid; else lo=mid;
    }
    const r=(lo+hi)/2;
    return {x:Math.cos(ang)*r, y:Math.sin(ang)*r};
  }

  function drawRingWithGates(shape, rr, ringIdx){
    // draw ring by sampling and skipping gate spans (angular mask)
    const steps = 260;
    const gates = cutouts[ringIdx] || [];
    const approxR = Math.max(40, rr);
    const spans = gates.map(g=>{
      const wAng = g.wLin / approxR;
      return {a:g.a, w:wAng};
    });

    function inAnyGate(a){
      for(const s of spans){
        const da = Math.atan2(Math.sin(a - s.a), Math.cos(a - s.a));
        if(Math.abs(da) < s.w/2) return true;
      }
      return false;
    }

    let drawing=false;
    for(let i=0;i<=steps;i++){
      const a = (i/steps)*Math.PI*2;
      if(inAnyGate(a)){
        if(drawing){ ctx.stroke(); drawing=false; }
        continue;
      }
      const p = pointOnIso(shape, a, rr);
      if(!drawing){ ctx.beginPath(); ctx.moveTo(p.x,p.y); drawing=true; }
      else ctx.lineTo(p.x,p.y);
    }
    if(drawing) ctx.stroke();

    // Gate markers (soft)
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(255,255,255,.20)";
    for(const g of gates){
      const p = pointOnIso(shape, g.a, rr);
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(3, wallT*0.45), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function pointOnIso(shape, ang, rr){
    // find point where sdf = rr - Riso ??? we need mapping: for rings, we use contour target -i*spacing.
    // Here rr is approximate geometric radius for drawing; use boundary-based scaling for visuals.
    // We'll simply use circle if circle shape, else use boundary point scaled inward.
    if(shape==="circle"){
      return {x:Math.cos(ang)*rr*0.78, y:Math.sin(ang)*rr*0.78};
    }
    // for other shapes: take boundary point at angle, scale to rr/R
    const boundary = pointOnBoundary(shape, ang, currentR);
    const bLen = Math.hypot(boundary.x, boundary.y) || 1;
    const scale = (rr*0.78) / bLen;
    return {x: boundary.x*scale, y: boundary.y*scale};
  }

  // We'll keep currentR global for drawing mapping.
  let currentR = 260;

  // ---------- Loop ----------
  let last = performance.now();
  function frame(t){
    const dt = Math.min(0.032, (t-last)/1000);
    last = t;

    updateKeys();
    const ax = (tiltX + keyX*0.85) * LOCKED.physics.accel;
    const ay = (tiltY + keyY*0.85) * LOCKED.physics.accel;
    tiltTxt.textContent = `${(tiltX+keyX*0.85).toFixed(2)},${(tiltY+keyY*0.85).toFixed(2)}`;

    const W = cv.clientWidth, H = cv.clientHeight;
    const R = Math.min(W,H) * 0.46;
    currentR = R;

    // integrate
    for(const b of balls){
      b.vx += ax*60*dt;
      b.vy += ay*60*dt;

      // cap
      b.vx = Math.max(-LOCKED.physics.maxV, Math.min(LOCKED.physics.maxV, b.vx));
      b.vy = Math.max(-LOCKED.physics.maxV, Math.min(LOCKED.physics.maxV, b.vy));

      b.x += b.vx;
      b.y += b.vy;

      b.vx *= Math.pow(LOCKED.physics.friction, 60*dt);
      b.vy *= Math.pow(LOCKED.physics.friction, 60*dt);
    }

    // resolve collisions (multiple passes for stability)
    for(let pass=0; pass<2; pass++){
      for(const b of balls){ applyBoundary(b, shape, R); }
      for(const b of balls){ applyRings(b, shape, R); }
      resolveBallBall();
    }

    draw(shape, R);

    // win indicator (subtle)
    if(allInPocket()){
      // tiny celebration ring
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(255,255,255,.08)";
      ctx.translate(W/2,H/2);
      ctx.beginPath();
      ctx.arc(0,0, centerPocketR()*1.25, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    requestAnimationFrame(frame);
  }

  // ---------- Init ----------
  function start(){
    syncSliders();
    buildLevel();
    requestAnimationFrame(frame);
  }
  start();

})();
</script>
</body>
</html>
