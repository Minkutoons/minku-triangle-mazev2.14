<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Maze Set 1 – Standard Shapes (Layout + Cutouts + Spawn + Sim)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#111; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { position:fixed; inset:0; touch-action:none; }

    #bar{
      position:fixed; left:10px; right:10px; top:10px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      z-index:30;
    }
    .btn{
      background:#1e88e5; color:#fff; border:none; border-radius:12px;
      padding:10px 12px; font-weight:850; cursor:pointer;
      box-shadow:0 6px 18px rgba(0,0,0,0.25);
      white-space:nowrap;
    }
    .btn.secondary{ background:#2e2e2e; font-weight:780; }
    .pill{
      padding:10px 12px; border-radius:12px;
      border:1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.06);
      color:#fff; font-weight:800; outline:none;
    }
    select.pill{ cursor:pointer; }

    #panel{
      position:fixed; left:10px; right:10px; bottom:10px;
      background:rgba(0,0,0,0.55); color:#fff;
      border:1px solid rgba(255,255,255,0.15);
      border-radius:14px; backdrop-filter:blur(6px);
      z-index:25; overflow:hidden;
      box-shadow:0 12px 28px rgba(0,0,0,0.35);
    }
    #panelHeader{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; gap:10px; }
    #panelBody{ max-height:38vh; overflow:auto; padding:10px 12px 12px; border-top:1px solid rgba(255,255,255,0.12); }

    #panel.collapsed #panelBody{ display:none; }
    #panel.collapsed #panelHeader{ border-bottom:none; }

    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .col{ flex:1 1 220px; }
    label{ font-size:12px; opacity:0.9; display:flex; justify-content:space-between; gap:8px; width:100%; }
    input[type="range"]{ width:100%; }

    #hint{
      position:fixed; top:62px; left:10px; right:10px;
      color:rgba(255,255,255,0.9); font-size:13px;
      padding:10px 12px; border-radius:14px;
      background:rgba(0,0,0,0.42);
      border:1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      pointer-events:none;
      z-index:20;
    }
    b{ font-weight:950; }
  </style>
</head>
<body>
  <div id="bar">
    <select id="shapeSel" class="pill" aria-label="Shape">
      <option value="circle" selected>Circle</option>
      <option value="square">Square</option>
      <option value="rect">Rectangle</option>
      <option value="hex">Hexagon</option>
    </select>

    <select id="logicSel" class="pill" aria-label="Logic">
      <option value="dense" selected>Dense Contours</option>
      <option value="erosion">Erosion Rings</option>
    </select>

    <button id="btnBuild" class="btn">Build</button>
    <button id="btnReset" class="btn secondary">Reset</button>
    <button id="btnSim" class="btn secondary">Sim: Off</button>
    <button id="btnPanel" class="btn secondary">Panel: On</button>

    <div class="pill" id="lockLine" style="opacity:0.95;">Lock v1</div>
  </div>

  <div id="hint">
    <b>Set 1:</b> Circle / Square / Rectangle / Hexagon ·
    <b>Inner Rings:</b> pixel-engine ·
    <b>Centre:</b> min diameter rule ·
    <b>Cutout:</b> angle + width + per-ring phase ·
    <b>Spawn:</b> outer ring marker ·
    <b>Sim:</b> demo runner (not physics)
  </div>

  <canvas id="c"></canvas>

  <div id="panel">
    <div id="panelHeader">
      <div style="font-weight:950;">Locked Parameters (v1)</div>
      <div id="statusLine" style="opacity:0.85; font-size:12px;">Auto-build on load</div>
    </div>
    <div id="panelBody">
      <div class="row">
        <div class="col">
          <label>Ball Diameter <span id="vBall">24</span></label>
          <input id="ballD" type="range" min="12" max="48" step="1" value="24" />
        </div>
        <div class="col">
          <label>Lane Gap <span id="vGap">48</span></label>
          <input id="laneGap" type="range" min="24" max="180" step="2" value="48" />
        </div>
        <div class="col">
          <label>Wall Thickness <span id="vWall">12</span></label>
          <input id="wallT" type="range" min="6" max="26" step="1" value="12" />
        </div>
      </div>

      <div style="height:10px;"></div>

      <div class="row">
        <div class="col">
          <label>Rings (max) <span id="vRings">14</span></label>
          <input id="maxRings" type="range" min="1" max="30" step="1" value="14" />
        </div>
        <div class="col">
          <label>Pixel Grid <span id="vGrid">320</span></label>
          <input id="gridN" type="range" min="192" max="640" step="64" value="320" />
        </div>
        <div class="col">
          <label>Render Smooth <span id="vSmooth">2</span></label>
          <input id="smooth" type="range" min="0" max="4" step="1" value="2" />
        </div>
      </div>

      <div style="height:10px;"></div>

      <div class="row">
        <div class="col">
          <label>Center Min (balls) <span id="vCenterBalls">4.4</span></label>
          <input id="centerBalls" type="range" min="3.0" max="8.0" step="0.1" value="4.4" />
        </div>
        <div class="col">
          <label>Cutout Angle (deg) <span id="vCutAng">25</span></label>
          <input id="cutAng" type="range" min="0" max="359" step="1" value="25" />
        </div>
        <div class="col">
          <label>Cutout Width (px) <span id="vCutW">34</span></label>
          <input id="cutW" type="range" min="16" max="120" step="1" value="34" />
        </div>
      </div>

      <div style="height:10px;"></div>

      <div class="row">
        <div class="col">
          <label>Cutout Phase / ring (deg) <span id="vCutPhase">55</span></label>
          <input id="cutPhase" type="range" min="0" max="180" step="1" value="55" />
        </div>
        <div class="col">
          <label>Polygon Chamfer (px) <span id="vChamfer">40</span></label>
          <input id="chamfer" type="range" min="0" max="140" step="2" value="40" />
        </div>
        <div class="col">
          <label>Rectangle Ratio (W/H) <span id="vRect">1.45</span></label>
          <input id="rectRatio" type="range" min="1.0" max="2.2" step="0.05" value="1.45" />
        </div>
      </div>

      <div style="height:10px;"></div>

      <div style="opacity:0.92; font-size:12px; line-height:1.35;">
        <b>Hard locks:</b>
        laneGap ≥ 2×ballD · ringPitch = laneGap + wallT · safeInset = wallT/2 + ballD/2 + 2px ·
        centerMinDiameter = centerBalls×ballD · cutoutWidth ≥ ballD (recommended)
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function resize(){
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth*dpr);
    canvas.height = Math.floor(window.innerHeight*dpr);
    canvas.style.width = window.innerWidth+'px';
    canvas.style.height = window.innerHeight+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', ()=>{ resize(); draw(); });
  resize();

  const el = {
    shapeSel: document.getElementById('shapeSel'),
    logicSel: document.getElementById('logicSel'),
    btnBuild: document.getElementById('btnBuild'),
    btnReset: document.getElementById('btnReset'),
    btnSim: document.getElementById('btnSim'),
    btnPanel: document.getElementById('btnPanel'),
    statusLine: document.getElementById('statusLine'),
    lockLine: document.getElementById('lockLine'),

    ballD: document.getElementById('ballD'),
    laneGap: document.getElementById('laneGap'),
    wallT: document.getElementById('wallT'),
    maxRings: document.getElementById('maxRings'),
    gridN: document.getElementById('gridN'),
    smooth: document.getElementById('smooth'),

    centerBalls: document.getElementById('centerBalls'),
    cutAng: document.getElementById('cutAng'),
    cutW: document.getElementById('cutW'),
    cutPhase: document.getElementById('cutPhase'),
    chamfer: document.getElementById('chamfer'),
    rectRatio: document.getElementById('rectRatio'),

    vBall: document.getElementById('vBall'),
    vGap: document.getElementById('vGap'),
    vWall: document.getElementById('vWall'),
    vRings: document.getElementById('vRings'),
    vGrid: document.getElementById('vGrid'),
    vSmooth: document.getElementById('vSmooth'),
    vCenterBalls: document.getElementById('vCenterBalls'),
    vCutAng: document.getElementById('vCutAng'),
    vCutW: document.getElementById('vCutW'),
    vCutPhase: document.getElementById('vCutPhase'),
    vChamfer: document.getElementById('vChamfer'),
    vRect: document.getElementById('vRect'),
  };

  const panel = document.getElementById('panel');

  const state = {
    boundaryPoly: null,
    ringsImage: null,
    simOn: false,
    sim: { ring:0, ang:0, lastT:0, speed:1.2 }
  };

  // ========= LOCKED PARAMETERS (single source of truth) =========
  function LOCKS(){
    const ballD = Number(el.ballD.value);
    const laneGap = Math.max(2*ballD, Number(el.laneGap.value));   // lock: laneGap >= 2*ballD
    const wallT = Number(el.wallT.value);
    const ringPitch = laneGap + wallT;                              // lock: pitch
    const safeInset = wallT/2 + ballD/2 + 2;                        // lock: safe inset
    const centerMinDiameter = Number(el.centerBalls.value) * ballD; // lock: centre rule
    const cutAngleDeg = Number(el.cutAng.value);
    const cutWidthPx  = Number(el.cutW.value);
    const cutPhaseDeg = Number(el.cutPhase.value);
    const chamferPx   = Number(el.chamfer.value);
    const rectRatio   = Number(el.rectRatio.value);
    const gridN       = Number(el.gridN.value);
    const smooth      = Number(el.smooth.value);
    const maxRings    = Number(el.maxRings.value);
    const logic       = el.logicSel.value;
    const shape       = el.shapeSel.value;
    return { ballD, laneGap, wallT, ringPitch, safeInset, centerMinDiameter, cutAngleDeg, cutWidthPx, cutPhaseDeg,
             chamferPx, rectRatio, gridN, smooth, maxRings, logic, shape };
  }

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

  function sync(){
    const { ballD, laneGap, wallT, maxRings, gridN, smooth, centerMinDiameter, cutAngleDeg, cutWidthPx, cutPhaseDeg, chamferPx, rectRatio } = LOCKS();

    // reflect clamped laneGap
    el.laneGap.value = String(laneGap);

    el.vBall.textContent = String(ballD|0);
    el.vGap.textContent  = String(laneGap|0);
    el.vWall.textContent = String(wallT|0);
    el.vRings.textContent= String(maxRings|0);
    el.vGrid.textContent = String(gridN|0);
    el.vSmooth.textContent=String(smooth|0);

    el.vCenterBalls.textContent = (Number(el.centerBalls.value)).toFixed(1);
    el.vCutAng.textContent = String(cutAngleDeg|0);
    el.vCutW.textContent = String(cutWidthPx|0);
    el.vCutPhase.textContent = String(cutPhaseDeg|0);
    el.vChamfer.textContent = String(chamferPx|0);
    el.vRect.textContent = rectRatio.toFixed(2);

    el.lockLine.textContent = `Lock v1 • centerMin=${(centerMinDiameter|0)}px • pitch=${(laneGap+wallT)|0}px • inset=${(wallT/2+ballD/2+2).toFixed(1)}px`;
  }

  ['input','change'].forEach(evt=>{
    ['ballD','laneGap','wallT','maxRings','gridN','smooth','shapeSel','logicSel','centerBalls','cutAng','cutW','cutPhase','chamfer','rectRatio']
      .forEach(id => el[id].addEventListener(evt, ()=>{ sync(); autoBuild(); }));
  });
  sync();

  // Mobile-friendly: start with panel collapsed
  if (window.innerWidth < 520) panel.classList.add('collapsed');
  el.btnPanel.textContent = panel.classList.contains('collapsed') ? 'Panel: Off' : 'Panel: On';

  // ---------- Geometry helpers ----------
  const densify=(pts,steps=18)=>{
    const dense=[];
    for(let i=0;i<pts.length;i++){
      const a=pts[i], b=pts[(i+1)%pts.length];
      for(let s=0;s<steps;s++){
        const t=s/steps;
        dense.push({ x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t });
      }
    }
    return dense;
  };

  function normalize(vx,vy){
    const m=Math.hypot(vx,vy)||1;
    return {x:vx/m, y:vy/m};
  }

  // Chamfer convex polygon corners by distance chamferPx
  function chamferPolygon(pts, chamferPx){
    if(chamferPx<=0) return pts;
    const out=[];
    const n=pts.length;
    for(let i=0;i<n;i++){
      const p=pts[(i-1+n)%n], v=pts[i], q=pts[(i+1)%n];
      const u1=normalize(p.x-v.x, p.y-v.y);
      const u2=normalize(q.x-v.x, q.y-v.y);
      const a={ x: v.x + u1.x*chamferPx, y: v.y + u1.y*chamferPx };
      const b={ x: v.x + u2.x*chamferPx, y: v.y + u2.y*chamferPx };
      out.push(a, b);
    }
    return out;
  }

  // ---------- Standard boundary generators (screen coords) ----------
  function makeCircle(cx,cy,r,n=240){
    const pts=[]; for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; pts.push({x:cx+r*Math.cos(a), y:cy+r*Math.sin(a)}); }
    return pts;
  }
  function makeRegularPolygon(cx,cy,r,sides, chamferPx=0){
    const pts=[];
    for(let i=0;i<sides;i++){
      const a=-Math.PI/2 + (i/sides)*Math.PI*2;
      pts.push({x:cx+r*Math.cos(a), y:cy+r*Math.sin(a)});
    }
    const cham=chamferPolygon(pts, chamferPx);
    return densify(cham, 18);
  }
  function makeRect(cx,cy,w,h, chamferPx=0){
    const pts=[
      {x:cx-w/2, y:cy-h/2},
      {x:cx+w/2, y:cy-h/2},
      {x:cx+w/2, y:cy+h/2},
      {x:cx-w/2, y:cy+h/2},
    ];
    const cham=chamferPolygon(pts, chamferPx);
    return densify(cham, 18);
  }

  function buildStandardBoundary(){
    const { shape, chamferPx, rectRatio } = LOCKS();
    const W=window.innerWidth, H=window.innerHeight;
    const pad=26;
    const cx=W/2, cy=H/2;
    const s=Math.min(W,H)/2 - pad;

    if (shape==='circle') return makeCircle(cx,cy,s,260);
    if (shape==='hex')    return makeRegularPolygon(cx,cy,s,6, chamferPx);
    if (shape==='square') return makeRegularPolygon(cx,cy,s,4, chamferPx);
    if (shape==='rect'){
      const w = Math.min(W-2*pad, (Math.min(W,H)-2*pad)*rectRatio);
      const h = Math.min(H-2*pad, (Math.min(W,H)-2*pad));
      const r = Math.min(w,h)/2;
      return makeRect(cx,cy, Math.min(w, 2*s*1.6), Math.min(h, 2*s*1.25), chamferPx);
    }
    return makeCircle(cx,cy,s,260);
  }

  // ---------- Pixel engine ----------
  function makeGrid(N){
    const W=window.innerWidth, H=window.innerHeight;
    const scale=Math.min(W,H)/N;
    const offX=(W-N*scale)/2;
    const offY=(H-N*scale)/2;
    return { N, scale, offX, offY,
      toGrid:(x,y)=>({
        gx: clamp(Math.floor((x-offX)/scale), 0, N-1),
        gy: clamp(Math.floor((y-offY)/scale), 0, N-1)
      }),
      toScreen:(gx,gy)=>({
        x: offX + (gx+0.5)*scale,
        y: offY + (gy+0.5)*scale
      })
    };
  }

  function rasterize(poly, grid){
    const N=grid.N;
    const off=document.createElement('canvas');
    off.width=N; off.height=N;
    const c=off.getContext('2d');
    c.clearRect(0,0,N,N);
    c.fillStyle='#fff';
    c.beginPath();
    const p0=grid.toGrid(poly[0].x, poly[0].y);
    c.moveTo(p0.gx+0.5, p0.gy+0.5);
    for(let i=1;i<poly.length;i++){
      const gp=grid.toGrid(poly[i].x, poly[i].y);
      c.lineTo(gp.gx+0.5, gp.gy+0.5);
    }
    c.closePath(); c.fill();
    const data=c.getImageData(0,0,N,N).data;
    const m=new Uint8Array(N*N);
    for(let i=0;i<N*N;i++) m[i] = data[i*4+3] ? 1 : 0;
    return m;
  }

  function largestComponent(mask, N){
    const seen=new Uint8Array(N*N);
    let best=null, bestSize=0;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(let i=0;i<N*N;i++){
      if(mask[i]===0||seen[i]) continue;
      const q=[i]; seen[i]=1; const comp=[i];
      while(q.length){
        const v=q.pop();
        const x=v%N, y=(v/N)|0;
        for(const [dx,dy] of dirs){
          const nx=x+dx, ny=y+dy;
          if(nx<0||nx>=N||ny<0||ny>=N) continue;
          const ni=ny*N+nx;
          if(mask[ni]===1&&!seen[ni]){ seen[ni]=1; q.push(ni); comp.push(ni); }
        }
      }
      if(comp.length>bestSize){ bestSize=comp.length; best=comp; }
    }
    if(!best) return mask;
    const out=new Uint8Array(N*N);
    for(const idx of best) out[idx]=1;
    return out;
  }

  function erode(mask, N, r){
    if(r<=0) return mask.slice();
    const out=new Uint8Array(N*N);
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx=y*N+x;
        if(mask[idx]===0){ out[idx]=0; continue; }
        let ok=1;
        const y0=Math.max(0,y-r), y1=Math.min(N-1,y+r);
        const x0=Math.max(0,x-r), x1=Math.min(N-1,x+r);
        for(let yy=y0; yy<=y1 && ok; yy++){
          const row=yy*N;
          for(let xx=x0; xx<=x1; xx++){
            if(mask[row+xx]===0){ ok=0; break; }
          }
        }
        out[idx]=ok;
      }
    }
    return out;
  }

  function subtract(a,b){
    const out=new Uint8Array(a.length);
    for(let i=0;i<a.length;i++) out[i] = (a[i]===1 && b[i]===0) ? 1 : 0;
    return out;
  }

  function distToOutside(mask, N){
    const INF=1e9;
    const d=new Float32Array(N*N);
    for(let i=0;i<N*N;i++) d[i] = mask[i] ? INF : 0;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const i=y*N+x;
        if(d[i]===0) continue;
        let best=d[i];
        if(x>0) best=Math.min(best, d[i-1]+1);
        if(y>0) best=Math.min(best, d[i-N]+1);
        if(x>0&&y>0) best=Math.min(best, d[i-N-1]+1.4142);
        if(x<N-1&&y>0) best=Math.min(best, d[i-N+1]+1.4142);
        d[i]=best;
      }
    }
    for(let y=N-1;y>=0;y--){
      for(let x=N-1;x>=0;x--){
        const i=y*N+x;
        if(d[i]===0) continue;
        let best=d[i];
        if(x<N-1) best=Math.min(best, d[i+1]+1);
        if(y<N-1) best=Math.min(best, d[i+N]+1);
        if(x<N-1&&y<N-1) best=Math.min(best, d[i+N+1]+1.4142);
        if(x>0&&y<N-1) best=Math.min(best, d[i+N-1]+1.4142);
        d[i]=best;
      }
    }
    return d;
  }

  // Angle helpers
  function wrapPi(a){
    while(a<=-Math.PI) a+=Math.PI*2;
    while(a> Math.PI) a-=Math.PI*2;
    return a;
  }

  function inCutoutSector(px,py,cx,cy,cutAngRad,angHalf){
    const a=Math.atan2(py-cy, px-cx);
    const da=wrapPi(a-cutAngRad);
    return Math.abs(da) <= angHalf;
  }

  function buildLayoutImage(poly){
    const { gridN, ballD, laneGap, wallT, safeInset, maxRings, ringPitch, logic, centerMinDiameter, cutAngleDeg, cutWidthPx, cutPhaseDeg } = LOCKS();
    const N=gridN;
    const grid=makeGrid(N);

    const cellPx=grid.scale;
    const toR = (px)=>Math.max(1, Math.floor(px/cellPx));

    // base mask
    let m0=rasterize(poly, grid);
    m0=largestComponent(m0, N);

    // safe inset (locks boundary protection)
    let m = largestComponent(erode(m0, N, toR(safeInset)), N);

    const img = ctx.createImageData(N, N);
    const data = img.data;

    const laneR = toR(laneGap);
    const wallR = toR(wallT);

    // For center rule: diameter ≈ 2*dMax*cellPx
    const centerStopCells = Math.max(2, (centerMinDiameter/2)/cellPx);

    // Used for cutout angular width: arcLen ≈ cutWidthPx => angWidth ≈ arcLen/radius
    const centerG = grid.toGrid(window.innerWidth/2, window.innerHeight/2);

    const shadeFor = (k)=> (k%2===0)?220:170;

    // Color palette: different for Dense vs Erosion (so you can visually compare versions)
    const baseRGB = (logic==='dense') ? {r:60,g:190,b:230} : {r:230,g:85,b:85};
    const colorFor = (k)=>{
      const s = (k%2===0) ? 1.0 : 0.78;
      return { r: Math.round(baseRGB.r*s), g: Math.round(baseRGB.g*s), b: Math.round(baseRGB.b*s) };
    };

    if (logic === 'erosion'){
      let curr=m;
      for(let k=0;k<maxRings;k++){
        // center stop based on current mask's maximum inscribed radius
        const d=distToOutside(curr, N);
        let dMax=0;
        for(let i=0;i<N*N;i++) if(curr[i] && d[i]>dMax) dMax=d[i];
        if(dMax <= centerStopCells) break;

        let inner=largestComponent(erode(curr, N, laneR), N);
        const ring=subtract(curr, inner);

        // approximate radius in pixels at this ring (use dMax as rough scale)
        const radiusPx = Math.max(1, dMax*cellPx);
        const angWidth = clamp(cutWidthPx / radiusPx, 0.10, 1.4); // radians
        const angHalf = angWidth/2;
        const cutAngRad = ((cutAngleDeg + k*cutPhaseDeg) * Math.PI/180);

        for(let y=0;y<N;y++){
          for(let x=0;x<N;x++){
            const i=y*N+x;
            if(!ring[i]) continue;
            // cutout by skipping pixels in sector
            if(inCutoutSector(x,y, centerG.gx, centerG.gy, cutAngRad, angHalf)) continue;
            const p=i*4;
            const c=colorFor(k);
            data[p]=c.r; data[p+1]=c.g; data[p+2]=c.b; data[p+3]=255;
          }
        }

        curr=largestComponent(erode(inner, N, wallR), N);
      }
    } else {
      // Dense contours from distance field
      const d=distToOutside(m, N);
      let dMax=0; for(let i=0;i<N*N;i++) if(m[i] && d[i]>dMax) dMax=d[i];

      const pitchCells = ringPitch / cellPx;
      const halfWall = Math.max(1, wallR/2);
      const start = (laneGap*0.6)/cellPx;

      let k=0;
      for(let t=start; t<dMax && k<maxRings; t+=pitchCells, k++){
        if(t >= dMax - centerStopCells) break; // center min diameter lock

        const radiusPx = Math.max(1, t*cellPx);
        const angWidth = clamp(cutWidthPx / radiusPx, 0.10, 1.4);
        const angHalf = angWidth/2;
        const cutAngRad = ((cutAngleDeg + k*cutPhaseDeg) * Math.PI/180);

        for(let y=0;y<N;y++){
          for(let x=0;x<N;x++){
            const i=y*N+x;
            if(!m[i]) continue;
            if(Math.abs(d[i]-t) <= halfWall){
              if(inCutoutSector(x,y, centerG.gx, centerG.gy, cutAngRad, angHalf)) continue;
              const p=i*4;
              const c=colorFor(k);
              data[p]=c.r; data[p+1]=c.g; data[p+2]=c.b; data[p+3]=255;
            }
          }
        }
      }
    }

    return {img, N, grid};
  }

  function draw(){
    const { smooth, ballD, cutAngleDeg } = LOCKS();
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
    ctx.fillStyle='#141414';
    ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

    if(state.ringsImage){
      const {img, N, grid} = state.ringsImage;
      const off=document.createElement('canvas');
      off.width=N; off.height=N;
      off.getContext('2d').putImageData(img,0,0);

      const scale=grid.scale;
      ctx.imageSmoothingEnabled = smooth > 0;
      ctx.drawImage(off, grid.offX, grid.offY, N*scale, N*scale);
    }

    // boundary outline
    if(state.boundaryPoly){
      ctx.save();
      ctx.lineWidth=3;
      ctx.strokeStyle='rgba(255,255,255,0.85)';
      ctx.fillStyle='rgba(255,255,255,0.05)';
      ctx.beginPath();
      ctx.moveTo(state.boundaryPoly[0].x, state.boundaryPoly[0].y);
      for(let i=1;i<state.boundaryPoly.length;i++) ctx.lineTo(state.boundaryPoly[i].x, state.boundaryPoly[i].y);
      ctx.closePath();
      ctx.stroke(); ctx.fill();
      ctx.restore();
    }

    // Spawn marker: on outer ring, opposite cutout
    if(state.ringsImage){
      const ang = (cutAngleDeg*Math.PI/180) + Math.PI; // opposite cutout
      const cx = window.innerWidth/2, cy = window.innerHeight/2;
      // place near boundary: use 42% of min dimension
      const r = Math.min(window.innerWidth, window.innerHeight)*0.42;
      const x = cx + r*Math.cos(ang);
      const y = cy + r*Math.sin(ang);
      ctx.save();
      ctx.fillStyle='rgba(255,255,255,0.92)';
      ctx.beginPath(); ctx.arc(x,y, ballD/2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='rgba(0,0,0,0.65)';
      ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('spawn', x - 16, y - ballD/2 - 10);
      ctx.restore();
    }

    // Sim runner (demo, not physics)
    if(state.simOn && state.ringsImage){
      const { ring, ang } = state.sim;
      const { laneGap, wallT, cutAngleDeg, cutPhaseDeg, cutWidthPx } = LOCKS();
      const cx=window.innerWidth/2, cy=window.innerHeight/2;

      const pitch = laneGap + wallT;
      const baseR = Math.min(window.innerWidth, window.innerHeight)*0.42;
      const r = Math.max(30, baseR - ring*pitch);

      const x = cx + r*Math.cos(ang);
      const y = cy + r*Math.sin(ang);

      ctx.save();
      ctx.fillStyle='rgba(255,255,255,0.92)';
      ctx.beginPath(); ctx.arc(x,y, Math.max(6, (Number(el.ballD.value)/2)*0.8), 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // draw current cutout direction for this ring
      const ca = ((cutAngleDeg + ring*cutPhaseDeg)*Math.PI/180);
      ctx.save();
      ctx.strokeStyle='rgba(255,255,255,0.35)';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.lineTo(cx + (r+30)*Math.cos(ca), cy + (r+30)*Math.sin(ca));
      ctx.stroke();
      ctx.restore();
    }
  }

  function build(){
    state.boundaryPoly = buildStandardBoundary();
    state.ringsImage = buildLayoutImage(state.boundaryPoly);
    draw();
    el.statusLine.textContent = `Built: ${el.shapeSel.options[el.shapeSel.selectedIndex].text} • ${el.logicSel.options[el.logicSel.selectedIndex].text} • cutouts ON`;
    // reset sim to outer ring
    state.sim.ring = 0;
    state.sim.ang = (Number(el.cutAng.value)*Math.PI/180) + Math.PI; // start opposite cutout
  }

  let autoTimer=null;
  function autoBuild(){
    clearTimeout(autoTimer);
    autoTimer=setTimeout(()=>{ build(); }, 90);
  }

  // --- Simulation: deterministic ring-to-ring via cutout angle ---
  function stepSim(ts){
    if(!state.simOn){ return; }
    const { laneGap, wallT, cutAngleDeg, cutPhaseDeg } = LOCKS();
    const dt = state.sim.lastT ? (ts - state.sim.lastT)/1000 : 0;
    state.sim.lastT = ts;

    // angular speed (demo)
    state.sim.ang += dt * state.sim.speed;

    // When near this ring's cutout angle, move inward (ring++)
    const target = ((cutAngleDeg + state.sim.ring*cutPhaseDeg) * Math.PI/180);
    const da = wrapPi(state.sim.ang - target);
    if(Math.abs(da) < 0.08){
      state.sim.ring += 1;
    }

    // clamp ring so it doesn't go too far
    const pitch = laneGap + wallT;
    const baseR = Math.min(window.innerWidth, window.innerHeight)*0.42;
    const r = baseR - state.sim.ring*pitch;
    if(r < 40){
      // reached center: restart
      state.sim.ring = 0;
      state.sim.ang = target + Math.PI;
    }

    draw();
    requestAnimationFrame(stepSim);
  }

  el.btnBuild.onclick = build;
  el.btnPanel.onclick = ()=>{
    panel.classList.toggle('collapsed');
    el.btnPanel.textContent = panel.classList.contains('collapsed') ? 'Panel: Off' : 'Panel: On';
  };

  el.btnReset.onclick = ()=>{
    state.ringsImage=null;
    state.simOn=false;
    el.btnSim.textContent = 'Sim: Off';
    draw();
    el.statusLine.textContent = 'Reset (tap Build)';
  };
  el.btnSim.onclick = ()=>{
    state.simOn = !state.simOn;
    el.btnSim.textContent = state.simOn ? 'Sim: On' : 'Sim: Off';
    state.sim.lastT = 0;
    draw();
    if(state.simOn) requestAnimationFrame(stepSim);
  };

  // Auto-build on load
  build();
})();
</script>
</body>
</html>
