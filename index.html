// ====== MAZE GATE GENERATOR (minimal, no physics) ======

const TAU = Math.PI * 2;

function normDeg(d) {
  d %= 360;
  return d < 0 ? d + 360 : d;
}

function degToRad(d) {
  return (d * Math.PI) / 180;
}

function sectorIndex(deg, sectorCount) {
  const size = 360 / sectorCount;
  return Math.floor(normDeg(deg) / size); // 0..sectorCount-1
}

// Pick a degree inside a sector, using "slot" to alternate position (early/late)
function pickInSector(sector, sectorCount, slot /*0 early,1 late*/, jitterDeg = 3) {
  const size = 360 / sectorCount;
  const start = sector * size;
  const base = start + (slot === 0 ? size * 0.25 : size * 0.75);
  const jitter = (Math.random() * 2 - 1) * jitterDeg;
  return normDeg(base + jitter);
}

// Count gates per sector (A+B only; you can include C if you want separately)
function countPerSector(gatesByRing, sectorCount) {
  const counts = Array(sectorCount).fill(0);
  for (const ring of gatesByRing) {
    for (const g of ring) {
      if (g.type === "A" || g.type === "B") counts[sectorIndex(g.deg, sectorCount)]++;
    }
  }
  return counts;
}

// Simple imbalance score: max - min
function imbalanceScore(counts) {
  let mn = Infinity, mx = -Infinity;
  for (const c of counts) { mn = Math.min(mn, c); mx = Math.max(mx, c); }
  return mx - mn;
}

/**
 * Generate gates for one level.
 * Output: gatesByRing = [ [A,B], [A,B], ..., [C] ]
 */
function generateGates({
  shapeType = "circle",     // "circle" | "polygon" | "triangle"
  ringCount = 4,            // N
  levelIndex = 1,           // 1-based
  baseShiftDeg = 22,        // spiral step
  shiftJitterDeg = 6,       // organic
  separationMinDeg = 140,
  separationMaxDeg = 170,
  ballD = 20,               // px
  cutoutWidthFactor = 1.3,  // relative to probe diameter
} = {}) {
  const sectorCount = (shapeType === "triangle") ? 6 : 4;

  // Bias: odd levels CW (+1), even levels CCW (-1)
  const bias = (levelIndex % 2 === 1) ? +1 : -1;

  const probeD = 1.5 * ballD;
  const cutoutWidth = cutoutWidthFactor * probeD; // linear gap width in px (for your builder)

  // Try a few times to get decent sector balance
  let best = null;

  for (let attempt = 0; attempt < 12; attempt++) {
    const gatesByRing = [];

    // Choose a quarter/sector distribution: balanced by construction via slot plan
    // Slots for sectors: weâ€™ll fill 2-2-1-1 pattern naturally by picking A in one sector, B in another, then shifting.
    // Start sector picks are random but controlled.
    const A0_sector = Math.floor(Math.random() * sectorCount);
    const A0_slot = attempt % 2; // alternate early/late
    let Adeg = pickInSector(A0_sector, sectorCount, A0_slot, 4);

    // Asymmetric B separated from A
    const sep = separationMinDeg + Math.random() * (separationMaxDeg - separationMinDeg);
    let Bdeg = normDeg(Adeg + sep);

    // Rings 1..N-1 have A & B
    for (let r = 1; r <= ringCount - 1; r++) {
      gatesByRing.push([
        { type: "A", deg: Adeg, widthPx: cutoutWidth },
        { type: "B", deg: Bdeg, widthPx: cutoutWidth },
      ]);

      const step = baseShiftDeg + (Math.random() * 2 - 1) * shiftJitterDeg;
      Adeg = normDeg(Adeg + bias * step);
      Bdeg = normDeg(Bdeg + bias * step);
    }

    // Ring N has single center gate C, placed between A(N-1) and B(N-1)
    // Compute midpoint on circle (short way) in degrees
    const last = gatesByRing[gatesByRing.length - 1];
    const A_last = last[0].deg;
    const B_last = last[1].deg;

    const mid = midpointAngleDeg(A_last, B_last);
    const Cdeg = normDeg(mid + (Math.random() * 2 - 1) * 8); // organic shift

    gatesByRing.push([{ type: "C", deg: Cdeg, widthPx: cutoutWidth }]);

    const counts = countPerSector(gatesByRing, sectorCount);
    const score = imbalanceScore(counts);

    if (!best || score < best.score) best = { gatesByRing, counts, score, bias, cutoutWidth, probeD };
    if (score <= 1) break; // good enough
  }

  return {
    shapeType,
    ringCount,
    levelIndex,
    biasDirection: best.bias, // +1 CW, -1 CCW
    probeDiameter: best.probeD,
    cutoutWidthPx: best.cutoutWidth,
    sectorCount: (shapeType === "triangle") ? 6 : 4,
    sectorCounts: best.counts,
    gatesByRing: best.gatesByRing,
  };
}

// Midpoint on circle in degrees (handles wrap-around)
function midpointAngleDeg(a, b) {
  a = normDeg(a); b = normDeg(b);
  let d = b - a;
  if (d > 180) d -= 360;
  if (d < -180) d += 360;
  return normDeg(a + d / 2);
}

// ====== PROBE CHECK HOOK (YOU CONNECT TO YOUR PHYSICS) ======
// You already have ball physics. This just defines required runs.
function getProbeRuns(plan) {
  // Intended inward direction follows bias (CW for +1, CCW for -1)
  return [
    { name: "A_to_C", startGate: "A", goalGate: "C", inward: true,  direction: plan.biasDirection },
    { name: "B_to_C", startGate: "B", goalGate: "C", inward: true,  direction: plan.biasDirection },
    { name: "C_to_OUT", startGate: "C", goalGate: "OUT", inward: false, direction: -plan.biasDirection },
  ];
}

/*
Usage:

const plan = generateGates({
  shapeType: "circle",
  ringCount: 4,
  levelIndex: 1,
  ballD: 18,
});

console.log(plan.gatesByRing, plan.sectorCounts);

Then build geometry with plan.gatesByRing:
- For circle: create cutout at angle deg with widthPx (convert widthPx to angle using ring radius)
- For polygon/triangle: cut a segment length widthPx on the wall, edges normal to wall face.

Probe:
const runs = getProbeRuns(plan);
For each run, spawn probe (diam=plan.probeDiameter) at startGate and simulate, record time & stuck.
*/
