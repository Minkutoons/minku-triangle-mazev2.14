<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Rock n Roll: Ball Maze Challenge â€“ Minku</title>
<style>
body{margin:0;background:#111;color:#fff;font-family:Arial}
#top{padding:8px;background:#1a1a1a;display:flex;gap:10px;align-items:center}
button{padding:6px 10px;border-radius:6px;border:none;background:#333;color:#fff}
canvas{display:block;width:100vw;height:90vh;touch-action:none}
</style>
</head>
<body>

<div id="top">
<button id="restart">Restart</button>
<button id="comfort">Comfort: ON</button>
<span id="info">Triangle (real edges)</span>
</div>

<canvas id="cv"></canvas>

<script>
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");

function resize(){
  const top = document.getElementById('top');
  const topH = top ? top.getBoundingClientRect().height : 0;
  cv.width = window.innerWidth;
  cv.height = Math.max(240, Math.floor(window.innerHeight - topH));
}
resize();
window.onresize = resize;

let shape = "triangle";
let comfortMode = true;

let ball = {x:0,y:0,vx:0,vy:0,r:12};

function resetBall(){
  ball.x = cv.width/2;
  ball.y = cv.height/2 - Math.min(120, cv.height*0.18);
  ball.vx = ball.vy = 0;
}
resetBall();

document.getElementById("restart").onclick = resetBall;

document.getElementById("comfort").onclick = ()=>{
  comfortMode = !comfortMode;
  document.getElementById("comfort").textContent =
    "Comfort: " + (comfortMode?"ON":"OFF");
};

let tiltX=0, tiltY=0;
window.addEventListener("deviceorientation",(e)=>{
  let gx=e.gamma||0;
  let by=e.beta||0;

  if(comfortMode){
    tiltX = by/30;
    tiltY = -gx/30;
  }else{
    tiltX = gx/30;
    tiltY = by/30;
  }
});

function drawShape(R){
  let cx=cv.width/2;
  let cy=cv.height/2;

  ctx.strokeStyle="#555";
  ctx.lineWidth=5;
  ctx.beginPath();

  if(shape==="circle"){
    ctx.arc(cx,cy,R,0,Math.PI*2);
  }

  if(shape==="square"){
    ctx.rect(cx-R,cy-R,R*2,R*2);
  }

  if(shape==="rect"){
    ctx.rect(cx-R*1.2,cy-R*0.7,R*2.4,R*1.4);
  }

  if(shape==="triangle"){
    // draw outer triangle with a small gate opening on one edge (matches physics gate above)
    const ax=cx, ay=cy-R;
    const bx=cx+R*Math.cos(Math.PI/6), by=cy+R*Math.sin(Math.PI/6);
    const cx2=cx-R*Math.cos(Math.PI/6), cy2=cy+R*Math.sin(Math.PI/6);
    const pts=[[ax,ay],[bx,by],[cx2,cy2]];

    function lerp(a,b,t){ return a + (b-a)*t; }

    for(let i=0;i<3;i++){
      const p0=pts[i], p1=pts[(i+1)%3];
      ctx.beginPath();
      if(i===GATE.edgeIndex){
        const t0 = clamp(GATE.tCenter - GATE.tHalf, 0, 1);
        const t1 = clamp(GATE.tCenter + GATE.tHalf, 0, 1);
        // segment before gate
        ctx.moveTo(p0[0], p0[1]);
        ctx.lineTo(lerp(p0[0],p1[0],t0), lerp(p0[1],p1[1],t0));
        // segment after gate
        ctx.moveTo(lerp(p0[0],p1[0],t1), lerp(p0[1],p1[1],t1));
        ctx.lineTo(p1[0], p1[1]);
      }else{
        ctx.moveTo(p0[0], p0[1]);
        ctx.lineTo(p1[0], p1[1]);
      }
      ctx.stroke();
    }
  }

  ctx.stroke();
}

function drawRings(R){
  let cx=cv.width/2;
  let cy=cv.height/2;
  let spacing = R/6;

  ctx.strokeStyle="#777";
  ctx.lineWidth=4;

  for(let i=1;i<=4;i++){
    ctx.beginPath();

    if(shape==="circle"){
      ctx.arc(cx,cy,R-i*spacing,0,Math.PI*2);
    }

    if(shape==="square"){
      ctx.rect(cx-(R-i*spacing),
               cy-(R-i*spacing),
               (R-i*spacing)*2,
               (R-i*spacing)*2);
    }

    if(shape==="rect"){
      ctx.rect(cx-(R-i*spacing)*1.2,
               cy-(R-i*spacing)*0.7,
               (R-i*spacing)*2.4,
               (R-i*spacing)*1.4);
    }

    if(shape==="triangle"){
      let r2=R-i*spacing;
      ctx.moveTo(cx,cy-r2);
      ctx.lineTo(cx+r2*Math.cos(Math.PI/6),
                 cy+r2*Math.sin(Math.PI/6));
      ctx.lineTo(cx-r2*Math.cos(Math.PI/6),
                 cy+r2*Math.sin(Math.PI/6));
      ctx.closePath();
    }

    ctx.stroke();
  }
}


function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function closestPointOnSegment(px,py, ax,ay, bx,by){
  const abx = bx-ax, aby = by-ay;
  const apx = px-ax, apy = py-ay;
  const t = clamp((apx*abx + apy*aby) / (abx*abx + aby*aby + 1e-9), 0, 1);
  return { x: ax + abx*t, y: ay + aby*t };
}

function pointInTri(px,py, ax,ay, bx,by, cx,cy){
  // barycentric (stable)
  const v0x = cx-ax, v0y = cy-ay;
  const v1x = bx-ax, v1y = by-ay;
  const v2x = px-ax, v2y = py-ay;

  const dot00 = v0x*v0x + v0y*v0y;
  const dot01 = v0x*v1x + v0y*v1y;
  const dot02 = v0x*v2x + v0y*v2y;
  const dot11 = v1x*v1x + v1y*v1y;
  const dot12 = v1x*v2x + v1y*v2y;

  const invDen = 1 / (dot00*dot11 - dot01*dot01 + 1e-9);
  const u = (dot11*dot02 - dot01*dot12) * invDen;
  const v = (dot00*dot12 - dot01*dot02) * invDen;
  return (u >= 0) && (v >= 0) && (u + v <= 1);
}

// Simple Triangle Gate (outer boundary only, Step: allow passing through one edge section)
const GATE = {
  edgeIndex: 0,        // 0: AB (top->right), 1: BC (right->left base), 2: CA (left->top)
  tCenter: 0.55,       // position along edge (0..1)
  tHalf: 0.12          // half-width along edge (0..0.5)
};

function clampBallToTriangle(ball, ax,ay, bx,by, cx,cy){
  const edges = [
    [ax,ay,bx,by],
    [bx,by,cx,cy],
    [cx,cy,ax,ay]
  ];

  // if outside, snap to nearest perimeter point
  if(!pointInTri(ball.x, ball.y, ax,ay, bx,by, cx,cy)){
    let best = null, bestD2 = 1e30;
    for(const e of edges){
      const p = closestPointOnSegment(ball.x, ball.y, e[0],e[1], e[2],e[3]);
      const dx = ball.x - p.x, dy = ball.y - p.y;
      const d2 = dx*dx + dy*dy;
      if(d2 < bestD2){ bestD2 = d2; best = p; }
    }
    ball.x = best.x;
    ball.y = best.y;
  }

  // ensure distance from each edge >= r (push away from edge)
  for(let ei=0; ei<edges.length; ei++){
    const e = edges[ei];

    // Gate: skip collision push for points near the gate segment on selected edge
    if(ei === GATE.edgeIndex){
      const ax3=e[0], ay3=e[1], bx3=e[2], by3=e[3];
      const abx=bx3-ax3, aby=by3-ay3;
      const apx=ball.x-ax3, apy=ball.y-ay3;
      const denom = (abx*abx + aby*aby + 1e-9);
      const t = clamp((apx*abx + apy*aby)/denom, 0, 1);
      if(Math.abs(t - GATE.tCenter) <= GATE.tHalf){
        continue; // opening: no wall push here
      }
    }

    const p = closestPointOnSegment(ball.x, ball.y, e[0],e[1], e[2],e[3]);
    const dx = ball.x - p.x, dy = ball.y - p.y;
    const d = Math.hypot(dx,dy) + 1e-9;
    if(d < ball.r){
      const push = (ball.r - d);
      ball.x += (dx/d)*push;
      ball.y += (dy/d)*push;
      ball.vx *= 0.92;
      ball.vy *= 0.92;
    }
  }
}


function loop(){
  ctx.clearRect(0,0,cv.width,cv.height);

  let cx=cv.width/2;
  let cy=cv.height/2;
  let R=Math.min(cv.width, cv.height)*0.42;

  drawShape(R);
  drawRings(R);

  ball.vx += tiltX;
  ball.vy += tiltY;
  ball.vx *= 0.98;
  ball.vy *= 0.98;
  ball.x += ball.vx;
  ball.y += ball.vy;
  // Triangle boundary clamp (real physics for Level 1)
  if(shape==="triangle"){
    const ax = cx, ay = cy - R;
    const bx = cx + R*Math.cos(Math.PI/6), by = cy + R*Math.sin(Math.PI/6);
    const cx2 = cx - R*Math.cos(Math.PI/6), cy2 = cy + R*Math.sin(Math.PI/6);
    clampBallToTriangle(ball, ax,ay, bx,by, cx2,cy2);
  } else {
    // fallback clamp for other shapes (kept simple)
    if(ball.x < cx-R+ball.r) ball.x = cx-R+ball.r;
    if(ball.x > cx+R-ball.r) ball.x = cx+R-ball.r;
    if(ball.y < cy-R+ball.r) ball.y = cy-R+ball.r;
    if(ball.y > cy+R-ball.r) ball.y = cy+R-ball.r;
  }

  ctx.fillStyle="gold";
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
  ctx.fill();

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
