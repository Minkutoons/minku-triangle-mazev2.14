<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Rock n Roll: Ball Maze Challenge â€“ Minku (Test)</title>
<style>
  :root { --bg:#141414; --panel:#1f1f1f; --text:#f3f3f3; --muted:#b9b9b9; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
  #top{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px 12px;background:#101010;border-bottom:1px solid #2a2a2a}
  .left,.right{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{background:var(--panel);border:1px solid #2b2b2b;border-radius:999px;padding:6px 10px;font-size:12px;color:var(--muted)}
  .btn{background:var(--panel);border:1px solid #2b2b2b;border-radius:10px;padding:8px 10px;color:var(--text);font-weight:600}
  .btn:active{transform:translateY(1px)}
  canvas{flex:1;display:block;touch-action:none;width:100%;height:100%}
</style>
</head>
<body>
<div id="wrap">
  <div id="top">
    <div class="left">
      <div class="pill"><b style="color:#fff">Rock n Roll</b> â€¢ Minku</div>
      <div class="pill" id="status">L1</div>
      <button class="btn" id="restart">Restart</button>
      <button class="btn" id="prev">Prev</button>
      <button class="btn" id="next">Next</button>
      <button class="btn" id="comfort">Comfort: ON</button>
    </div>
    <div class="right">
      <div class="pill">Tilt: <span id="tiltTxt">0,0</span></div>
    </div>
  </div>
  <canvas id="cv"></canvas>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const statusEl = document.getElementById('status');
  const tiltTxt = document.getElementById('tiltTxt');

  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
    const w = cv.parentElement.clientWidth;
    const h = cv.parentElement.clientHeight;
    cv.width  = Math.floor(w * dpr);
    cv.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('load', resize);
  window.addEventListener('resize', resize);
  resize();

  // ---- Level plan (Circle unlock @ 5) ----
  function shapeForLevel(L){
    if (L===1) return "triangle";
    if (L===2) return "square";
    if (L===3) return "rect";
    if (L===4) return "square";
    if (L>=5) return "circle";
    return "square";
  }
  function ringCountForLevel(L){
    if (L<=2) return 6;
    if (L<=5) return 7;
    if (L<=10) return 8;
    if (L<=15) return 9;
    return 10;
  }
  function cutoutWidthForLevel(L){
    if (L<=2) return 70;
    if (L<=5) return 60;
    if (L<=10) return 52;
    if (L<=15) return 46;
    return 42;
  }
  function wallThicknessForLevel(L){
    return (L<=5) ? 10 : (L<=12 ? 11 : 12);
  }

  let level = 1;
  let shape = shapeForLevel(level);
  let rings = ringCountForLevel(level);
  let cutW = cutoutWidthForLevel(level) * Math.PI/180;
  let wallT = wallThicknessForLevel(level);

  // cutouts per ring
  let cutouts = [];
  function regenMaze(){
    shape = shapeForLevel(level);
    rings = ringCountForLevel(level);
    cutW  = cutoutWidthForLevel(level) * Math.PI/180;
    wallT = wallThicknessForLevel(level);

    cutouts = [];
    const base = Math.random()*Math.PI*2;
    for(let i=1;i<=rings;i++){
      cutouts.push({ a: base + i*0.9, w: Math.max(cutW*(1 - i*0.015), 0.45) });
    }
    resetBall();
    statusEl.textContent = `L${level} â€¢ ${shape.toUpperCase()} â€¢ ${level<5?"Circle ðŸ”’":"Circle âœ…"}`;
  }

  // ---- Comfort mode default ON ----
  let comfortMode = true;
  const comfortBtn = document.getElementById('comfort');
  comfortBtn.textContent = "Comfort: ON";
  comfortBtn.onclick = () => {
    comfortMode = !comfortMode;
    comfortBtn.textContent = `Comfort: ${comfortMode ? 'ON' : 'OFF'}`;
  };

  // ---- Tilt input ----
  let tiltX = 0, tiltY = 0;
  window.addEventListener('deviceorientation', (e) => {
    const gx = (e.gamma ?? 0); // left-right
    const by = (e.beta ?? 0);  // front-back
    if (comfortMode){
      // portrait-friendly mapping
      tiltX = Math.max(-20, Math.min(20, by)) / 20;
      tiltY = Math.max(-20, Math.min(20, -gx)) / 20;
    } else {
      // landscape-friendly mapping
      tiltX = Math.max(-20, Math.min(20, gx)) / 20;
      tiltY = Math.max(-20, Math.min(20, by)) / 20;
    }
  }, {passive:true});

  // keyboard fallback
  const keys = new Set();
  window.addEventListener('keydown', (e)=> keys.add(e.key.toLowerCase()));
  window.addEventListener('keyup',   (e)=> keys.delete(e.key.toLowerCase()));
  function keyVec(){
    let x=0,y=0;
    if (keys.has('arrowleft')||keys.has('a')) x-=1;
    if (keys.has('arrowright')||keys.has('d')) x+=1;
    if (keys.has('arrowup')||keys.has('w')) y-=1;
    if (keys.has('arrowdown')||keys.has('s')) y+=1;
    const m=Math.hypot(x,y)||1;
    return {x:x/m,y:y/m};
  }

  // ---- SDF geometry ----
  function sdfCircle(x,y,R){ return Math.hypot(x,y) - R; }
  function sdfBox(x,y,hx,hy){
    const ax = Math.abs(x) - hx;
    const ay = Math.abs(y) - hy;
    const ox = Math.max(ax,0), oy = Math.max(ay,0);
    return Math.hypot(ox,oy) + Math.min(Math.max(ax,ay),0);
  }
  function sdfEquiTri(x,y,R){
    const k = Math.sqrt(3);
    x = Math.abs(x) - R;
    y = y + R/k;
    if (x + k*y > 0){
      const nx = (x - k*y)/2;
      const ny = (-k*x - y)/2;
      x = nx; y = ny;
    }
    x -= Math.max(Math.min(x,0), -2*R);
    return -Math.hypot(x,y) * Math.sign(y);
  }
  function sdfShape(shape, x,y, R){
    if (shape==="circle") return sdfCircle(x,y,R);
    if (shape==="square") return sdfBox(x,y,R,R);
    if (shape==="rect")   return sdfBox(x,y,R*1.15,R*0.85);
    if (shape==="triangle") return sdfEquiTri(x,y,R*0.95);
    return sdfCircle(x,y,R);
  }
  function gradSdf(shape, x,y,R){
    const e=0.8;
    const dx = sdfShape(shape,x+e,y,R) - sdfShape(shape,x-e,y,R);
    const dy = sdfShape(shape,x,y+e,R) - sdfShape(shape,x,y-e,R);
    const m=Math.hypot(dx,dy)||1;
    return {gx:dx/m, gy:dy/m};
  }

  // ---- Ball ----
  const ball = { x:0, y:0, vx:0, vy:0, r:10 };
  function resetBall(){
    ball.vx=ball.vy=0;
    ball.x = -80;
    ball.y = -60;
  }

  // ---- Collision: boundary clamp + ring walls ----
  function applyCollisions(R){
    // 1) hard boundary clamp (no outside)
    let d = sdfShape(shape, ball.x, ball.y, R);
    if (d > -ball.r){
      const {gx,gy} = gradSdf(shape, ball.x, ball.y, R);
      const push = (d + ball.r) + 0.6;
      ball.x -= gx*push;
      ball.y -= gy*push;
      ball.vx *= 0.4; ball.vy *= 0.4;
    }

    // 2) ring walls along sdf contours with cutouts
    const ringSpacing = (R - 40) / (rings + 1);
    for(let i=1;i<=rings;i++){
      const target = -i * ringSpacing;
      d = sdfShape(shape, ball.x, ball.y, R);
      const band = Math.abs(d - target);
      if (band < (wallT/2 + ball.r*0.55)){
        const ang = Math.atan2(ball.y, ball.x);
        const co = cutouts[i-1];
        const da = Math.atan2(Math.sin(ang-co.a), Math.cos(ang-co.a));
        const inCut = Math.abs(da) < (co.w/2);
        if (!inCut){
          const {gx,gy} = gradSdf(shape, ball.x, ball.y, R);
          const sign = (d > target) ? 1 : -1;
          const push = (wallT/2 + ball.r*0.6) - band + 0.8;
          ball.x += gx * push * sign;
          ball.y += gy * push * sign;
          ball.vx *= 0.55; ball.vy *= 0.55;
        }
      }
    }
  }

  function checkWin(){
    return Math.hypot(ball.x, ball.y) < 18;
  }

  // ---- Draw boundary path (triangle is upright now) ----
  function pathBoundary(shape, R){
    ctx.beginPath();
    if (shape==="circle"){
      ctx.arc(0,0,R,0,Math.PI*2); return;
    }
    if (shape==="square"){
      ctx.rect(-R,-R,R*2,R*2); return;
    }
    if (shape==="rect"){
      const hx=R*1.15, hy=R*0.85;
      ctx.rect(-hx,-hy,hx*2,hy*2); return;
    }
    if (shape==="triangle"){
      const r=R*0.95;
      ctx.moveTo(0, -r);
      ctx.lineTo( r*Math.cos(Math.PI/6),  r*Math.sin(Math.PI/6));
      ctx.lineTo(-r*Math.cos(Math.PI/6),  r*Math.sin(Math.PI/6));
      ctx.closePath();
      return;
    }
    ctx.arc(0,0,R,0,Math.PI*2);
  }

  // ---- Draw rings by marching along angles (visual only) ----
  function draw(R){
    ctx.clearRect(0,0,cv.clientWidth,cv.clientHeight);
    ctx.save();
    ctx.translate(cv.clientWidth/2, cv.clientHeight/2);

    // base
    ctx.fillStyle="#0f0f0f";
    ctx.fillRect(-cv.clientWidth/2,-cv.clientHeight/2,cv.clientWidth,cv.clientHeight);

    // outer base plate
    ctx.fillStyle="#1b1b1b";
    pathBoundary(shape, R+18);
    ctx.fill();

    // boundary stroke
    ctx.strokeStyle="#3a3a3a";
    ctx.lineWidth=2;
    pathBoundary(shape, R);
    ctx.stroke();

    const ringSpacing = (R - 40) / (rings + 1);

    // rings
    for(let i=1;i<=rings;i++){
      const target = -i * ringSpacing;

      // contour path
      const steps=220;
      ctx.beginPath();
      for(let s=0;s<=steps;s++){
        const ang = (s/steps)*Math.PI*2;
        let lo=0, hi=R*1.4;
        for(let it=0;it<18;it++){
          const mid=(lo+hi)/2;
          const x=Math.cos(ang)*mid, y=Math.sin(ang)*mid;
          const d=sdfShape(shape,x,y,R);
          if (d > target) hi=mid; else lo=mid;
        }
        const rr=(lo+hi)/2;
        const x=Math.cos(ang)*rr, y=Math.sin(ang)*rr;
        if (s===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();

      ctx.strokeStyle="#2f2f2f";
      ctx.lineWidth=wallT;
      ctx.lineCap="round";
      ctx.stroke();

      // erase cutout
      const co=cutouts[i-1];
      const a0=co.a-co.w/2, a1=co.a+co.w/2;
      ctx.save();
      ctx.globalCompositeOperation="destination-out";
      ctx.beginPath();
      const steps2=60;
      for(let s=0;s<=steps2;s++){
        const ang=a0+(s/steps2)*(a1-a0);
        let lo=0, hi=R*1.4;
        for(let it=0;it<16;it++){
          const mid=(lo+hi)/2;
          const x=Math.cos(ang)*mid, y=Math.sin(ang)*mid;
          const d=sdfShape(shape,x,y,R);
          if (d > target) hi=mid; else lo=mid;
        }
        const rr=(lo+hi)/2;
        const x=Math.cos(ang)*rr, y=Math.sin(ang)*rr;
        if (s===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.strokeStyle="#000";
      ctx.lineWidth=wallT+6;
      ctx.stroke();
      ctx.restore();
    }

    // center target
    ctx.fillStyle="#151515";
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="#5a5a5a"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.stroke();

    // ball
    const grad = ctx.createRadialGradient(ball.x-4,ball.y-6,2,ball.x,ball.y,ball.r+6);
    grad.addColorStop(0,"#fff1b8");
    grad.addColorStop(1,"#caa93b");
    ctx.fillStyle=grad;
    ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="#5b4b15"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.stroke();

    ctx.restore();
  }

  // ---- Controls ----
  document.getElementById('restart').onclick = resetBall;
  document.getElementById('prev').onclick = () => { level=Math.max(1,level-1); regenMaze(); };
  document.getElementById('next').onclick = () => { level=Math.min(30,level+1); regenMaze(); };

  // ---- Loop ----
  let last=performance.now();
  function tick(t){
    const dt=Math.min(0.02,(t-last)/1000); last=t;

    const kv = keyVec();
    const ax = (tiltX*0.9 + kv.x*0.85) * 950;
    const ay = (tiltY*0.9 + kv.y*0.85) * 950;
    tiltTxt.textContent = `${(tiltX*10).toFixed(1)},${(tiltY*10).toFixed(1)}`;

    ball.vx += ax*dt;
    ball.vy += ay*dt;
    ball.vx *= (1 - 3.2*dt);
    ball.vy *= (1 - 3.2*dt);

    ball.x += ball.vx*dt;
    ball.y += ball.vy*dt;

    const R = Math.min(cv.clientWidth, cv.clientHeight)*0.38;

    applyCollisions(R);

    if (checkWin()){
      if (navigator.vibrate) navigator.vibrate(20);
      level = Math.min(30, level+1);
      regenMaze();
    }

    draw(R);
    requestAnimationFrame(tick);
  }

  // Touch drag tilt assist
  let dragging=false, sx=0, sy=0;
  cv.addEventListener('pointerdown',(e)=>{dragging=true;sx=e.clientX;sy=e.clientY;});
  cv.addEventListener('pointermove',(e)=>{
    if(!dragging) return;
    const dx=(e.clientX-sx)/150;
    const dy=(e.clientY-sy)/150;
    tiltX=Math.max(-1,Math.min(1,dx));
    tiltY=Math.max(-1,Math.min(1,dy));
  });
  window.addEventListener('pointerup',()=>dragging=false);

  regenMaze();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
